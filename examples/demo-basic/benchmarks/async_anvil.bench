use std::anvil

suite evmBench {
    description: "EVM benchmark demonstrating Anvil integration"
    baseline: "go"
    mode: "auto"
    targetTime: 8000ms
    cvThreshold: 10
    warmup: 10
    count: 5
     fairness: "strict"
    fairnessSeed: 20260223
    asyncSamplingPolicy: "timeBudgeted"
    asyncWarmupCap: 8
    asyncSampleCap: 500

    globalSetup {
        anvil.spawnAnvil(fork: "https://eth.drpc.org")
    }

    setup go {
        import (
            "github.com/ChefBingbong/viem-go/actions/public"
            "context"
            "time"
            "github.com/ChefBingbong/viem-go/chain/definitions"
            "github.com/ChefBingbong/viem-go/client"
            "github.com/ChefBingbong/viem-go/client/transport"
        )

        declare {
            var publicClient *client.PublicClient
            var ctx context.Context
            var noCache time.Duration
        }

        init {
            ctx = context.Background()

            _publicClient, err := client.CreatePublicClient(client.PublicClientConfig{
                CacheTime: 0 *  time.Second,
                Chain:     &definitions.Mainnet,
                Transport: transport.HTTP( ANVIL_RPC_URL),
            })

            if err != nil {
                panic("Error creating client: %v\n")
            }

            publicClient = _publicClient
            noCache = 0
        }

        helpers {
            func getBlockNumberGo()  any {
                blockNumber, err := public.GetBlockNumber(
                    ctx,
                    publicClient,
                    public.GetBlockNumberParameters{ CacheTime: &noCache },
                )
                if err != nil {
                    panic(err)
                }
                return blockNumber
            }
        }
    }

    setup ts {
        import {
            import { createPublicClient, http } from 'viem'
            import { mainnet } from 'viem/chains'
        }

        declare {
            let publicClient: any 
        }

        init {
            publicClient = createPublicClient({
                cacheTime: 0,
                chain: mainnet,
                transport: http(ANVIL_RPC_URL),
            })
        }

        helpers {
            async function getBlockNumberTs() {
                return await publicClient.getBlockNumber()
            }
        }
    }

    setup rust {
        import {
            use alloy::providers::{Provider, ProviderBuilder};
        }

        declare {
            type HttpProvider = alloy::providers::RootProvider<
                alloy::transports::http::Http<alloy::transports::http::reqwest::Client>
            >;
           
        }

        init {
            static mut publicClient = ProviderBuilder::new().connect_http(ANVIL_RPC_URL); 
        }

        helpers {
            fn getBlockNumberRust() -> u64 {
                let provider = unsafe {
                    publicClient
                        .as_ref()
                        .expect("publicClient was not initialized in setup rust init")
                };
                let rt = tokio::runtime::Runtime::new().expect("failed to create tokio runtime");
                rt.block_on(async {
                    provider
                        .get_block_number()
                        .await
                        .expect("failed to fetch block number")
                })
            }
        }
    }

    benchAsync getBlockNumber {
        description: "Get the current block number via RPC"
        go: getBlockNumberGo()
        ts: getBlockNumberTs()
        rust: getBlockNumberRust()
    }

    after {
        charting.drawSpeedupChart(
            title: "Sort Performance - O(n log n)",
            description: "Stdlib sort comparison across Go, TypeScript, and Rust",
            output: "anvil.svg",
        )
        charting.drawTable(
            title: "Sort Performance Comparison",
            description: "Vertical grouped bars - Go vs TypeScript vs Rust",
            output: "anvil-report.svg",
        )
    }
}
