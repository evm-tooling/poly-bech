use std::charting

suite regexN {
    description: "Regex backtracking (a+)+b on string 'a'*n+'b'"
    warmup: 50
    baseline: "go"
    mode: "auto"
    targetTime: 3000ms
    cvThreshold: 5
    count: 1
    memory: true

    setup go {
        import (
        "encoding/binary"
        "regexp"
        )

        helpers {
            func regexGo(data []byte) []byte {
                n := binary.LittleEndian.Uint32(data[0:4])
                s := ""
                for i := uint32(0); i < n; i++ {
                    s += "a"
                }
                s += "b"
                re := regexp.MustCompile("(a+)+b")
                out := re.Find([]byte(s))
                if out == nil {
                    return []byte{0}
                }
                return out
            }
        }
    }

    setup ts {
        helpers {
            function regexTs(data: Uint8Array): Uint8Array {
                const n = new DataView(data.buffer, data.byteOffset, 4).getUint32(0, true)
                const s = 'a'.repeat(n) + 'b'
                const re = /(a+)+b/
                const m = s.match(re)
                return m ? new TextEncoder().encode(m[0]) : new Uint8Array(1)
            }
        }
    }

    setup rust {
        import {
            use regex::Regex;
        }

        helpers {
            fn regex_rust(data: &[u8]) -> Vec<u8> {
                let n = u32::from_le_bytes(data[0..4].try_into().unwrap()) as usize;
                let s = "a".repeat(n) + "b";
                let re = Regex::new("(a+)+b").unwrap();
                re.find(&s).map(|m| m.as_str().as_bytes().to_vec()).unwrap_or_else(|| vec![0])
            }
        }
    }

    fixture r10 {
        hex: @file("fixtures/regex/re_10.hex")
    }

    fixture r20 {
        hex: @file("fixtures/regex/re_20.hex")
    }

    fixture r30 {
        hex: @file("fixtures/regex/re_30.hex")
    }

    fixture r40 {
        hex: @file("fixtures/regex/re_40.hex")
    }

    fixture r50 {
        hex: @file("fixtures/regex/re_50.hex")
    }

    fixture r60 {
        hex: @file("fixtures/regex/re_60.hex")
    }

    fixture r70 {
        hex: @file("fixtures/regex/re_70.hex")
    }

    fixture r80 {
        hex: @file("fixtures/regex/re_80.hex")
    }

    fixture r90 {
        hex: @file("fixtures/regex/re_90.hex")
    }

    fixture r100 {
        hex: @file("fixtures/regex/re_100.hex")
    }

    bench len10 {
        go: regexGo(r10)
        ts: regexTs(r10)
        rust: regex_rust(&r10)
    }

    bench len20 {
        go: regexGo(r20)
        ts: regexTs(r20)
        rust: regex_rust(&r20)
    }

    bench len30 {
        go: regexGo(r30)
        ts: regexTs(r30)
        rust: regex_rust(&r30)
    }

    bench len40 {
        go: regexGo(r40)
        ts: regexTs(r40)
        rust: regex_rust(&r40)
    }

    bench len50 {
        go: regexGo(r50)
        ts: regexTs(r50)
        rust: regex_rust(&r50)
    }

    bench len60 {
        go: regexGo(r60)
        ts: regexTs(r60)
        rust: regex_rust(&r60)
    }

    bench len70 {
        go: regexGo(r70)
        ts: regexTs(r70)
        rust: regex_rust(&r70)
    }

    bench len80 {
        go: regexGo(r80)
        ts: regexTs(r80)
        rust: regex_rust(&r80)
    }

    bench len90 {
        go: regexGo(r90)
        ts: regexTs(r90)
        rust: regex_rust(&r90)
    }

    bench len100 {
        go: regexGo(r100)
        ts: regexTs(r100)
        rust: regex_rust(&r100)
    }

    after {
        charting.drawSpeedupChart(
            title: "Regex Matching Performance",
            description: "Email regex matching across input lengths",
            output: "regex-line.svg",
            xlabel: "Input Length (chars)"
        )

        charting.drawTable(
            title: "Regex Matching Comparison",
            description: "Vertical grouped bars - regex engine comparison",
            output: "regex-bar.svg",
            xlabel: "Input Length"
        )
    }

}
