use std::charting

declare suite bubbleN performance timeBased sameDataset: true {
    description: "O(n^2) bubble sort on int32 array"
    baseline: "go"
    warmup: 20
    targetTime: 5000ms
    cvThreshold: 5
    count: 5

    setup go {
        import (
            "encoding/binary"
        )

        helpers {
            func bubbleGo(data []byte) []byte {
                n := len(data) / 4
                arr := make([]int32, n)
                for i := 0; i < n; i++ {
                    arr[i] = int32(binary.BigEndian.Uint32(data[i*4 : (i+1)*4]))
                }
                for i := 0; i < n; i++ {
                    for j := 0; j < n-1-i; j++ {
                        if arr[j] > arr[j+1] {
                            arr[j], arr[j+1] = arr[j+1], arr[j]
                        }
                    }
                }
                out := make([]byte, len(data))
                for i := 0; i < n; i++ {
                    binary.BigEndian.PutUint32(out[i*4:(i+1)*4], uint32(arr[i]))
                }
                return out
            }
        }
    }

    setup ts {
        helpers {
            function bubbleTs(data: Uint8Array): Uint8Array {
                const n = data.length / 4
                const arr = []
                for (let i = 0; i < n; i++) {
                    arr.push(data[i*4]<<24 | data[i*4+1]<<16 | data[i*4+2]<<8 | data[i*4+3])
                }
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n - 1 - i; j++) {
                        if (arr[j] > arr[j+1]) {
                            const tmp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = tmp
                        }
                    }
                }
                const out = new Uint8Array(data.length)
                for (let i = 0; i < n; i++) {
                    const v = (arr[i] >>> 0)
                    out[i*4] = (v>>24)&0xff; out[i*4+1] = (v>>16)&0xff
                    out[i*4+2] = (v>>8)&0xff; out[i*4+3] = v&0xff
                }
                return out
            }
        }
    }

    setup python {
        import {
            import struct
        }

        helpers {
            def bubble_python(data):
                n = len(data) // 4
                fmt = ">" + str(n) + "i"
                arr = list(struct.unpack(fmt, data))
                for i in range(n):
                    for j in range(n - 1 - i):
                        if arr[j] > arr[j + 1]:
                            arr[j], arr[j + 1] = arr[j + 1], arr[j]
                return struct.pack(fmt, *arr)
        }
    }

    setup rust {
        helpers {
            fn bubble_rust(data: &[u8]) -> Vec<u8> {
                let n = data.len() / 4;
                let mut arr: Vec<i32> = (0..n).map(|i| {
                    let j = i * 4;
                    i32::from_be_bytes([data[j], data[j+1], data[j+2], data[j+3]])
                }).collect();
                for i in 0..n {
                    for j in 0..n-1-i {
                        if arr[j] > arr[j+1] {
                            arr.swap(j, j+1);
                        }
                    }
                }
                let mut out = vec![0u8; data.len()];
                for (i, &v) in arr.iter().enumerate() {
                    out[i*4..(i+1)*4].copy_from_slice(&v.to_be_bytes());
                }
                out
            }
        }
    }
    
    setup csharp {
        import {
            using System;
            using System.Buffers.Binary;
        }

        helpers {
            static byte[] BubbleCsharp(byte[] data) {
                int n = data.Length / 4;
                int[] arr = new int[n];
                for (int i = 0; i < n; i++) {
                    int j = i * 4;
                    arr[i] = BinaryPrimitives.ReadInt32BigEndian(new ReadOnlySpan<byte>(data, j, 4));
                }
                for (int i = 0; i < n; i++) {
                    for (int j = 0; j < n - 1 - i; j++) {
                        if (arr[j] > arr[j + 1]) {
                            int tmp = arr[j];
                            arr[j] = arr[j + 1];
                            arr[j + 1] = tmp;
                        }
                    }
                }
                byte[] outBytes = new byte[data.Length];
                for (int i = 0; i < n; i++) {
                    int j = i * 4;
                    BinaryPrimitives.WriteInt32BigEndian(new Span<byte>(outBytes, j, 4), arr[i]);
                }
                return outBytes;
            }
        }
    }

    setup c {
        helpers {
            static int32_t read_i32_be(const unsigned char* p) {
                return (int32_t)(
                    ((uint32_t)p[0] << 24) |
                    ((uint32_t)p[1] << 16) |
                    ((uint32_t)p[2] << 8) |
                    (uint32_t)p[3]
                );
            }

            static void write_i32_be(unsigned char* p, int32_t v) {
                uint32_t u = (uint32_t)v;
                p[0] = (unsigned char)((u >> 24) & 0xFF);
                p[1] = (unsigned char)((u >> 16) & 0xFF);
                p[2] = (unsigned char)((u >> 8) & 0xFF);
                p[3] = (unsigned char)(u & 0xFF);
            }

            static void bubble_c(unsigned char* data, size_t len) {
                size_t n = len / 4;
                for (size_t i = 0; i < n; i++) {
                    for (size_t j = 0; j + 1 < n - i; j++) {
                        int32_t a = read_i32_be(data + j * 4);
                        int32_t b = read_i32_be(data + (j + 1) * 4);
                        if (a > b) {
                            write_i32_be(data + j * 4, b);
                            write_i32_be(data + (j + 1) * 4, a);
                        }
                    }
                }
            }
        }
    }

    fixture s100 {
        hex: @file("fixtures/sort/sort_100.hex")
    }

    fixture s200 {
        hex: @file("fixtures/sort/sort_200.hex")
    }

    fixture s300 {
        hex: @file("fixtures/sort/sort_300.hex")
    }

    fixture s400 {
        hex: @file("fixtures/sort/sort_400.hex")
    }

    fixture s500 {
        hex: @file("fixtures/sort/sort_500.hex")
    }

    fixture s600 {
        hex: @file("fixtures/sort/sort_600.hex")
    }

    fixture s700 {
        hex: @file("fixtures/sort/sort_700.hex")
    }

    fixture s800 {
        hex: @file("fixtures/sort/sort_800.hex")
    }

    fixture s900 {
        hex: @file("fixtures/sort/sort_900.hex")
    }

    fixture s1000 {
        hex: @file("fixtures/sort/sort_1000.hex")
    }

    bench n100 {
        go: bubbleGo(s100)
        ts: bubbleTs(s100)
        rust: bubble_rust(&s100)
        python: bubble_python(s100)
        csharp: BubbleCsharp(s100);
        c: bubble_c(s100, sizeof(s100))
    }

    bench n200 {
        go: bubbleGo(s200)
        ts: bubbleTs(s200)
        rust: bubble_rust(&s200)
        python: bubble_python(s200)
        csharp: BubbleCsharp(s200);
        c: bubble_c(s200, sizeof(s200))
    }

    bench n300 {
        go: bubbleGo(s300)
        ts: bubbleTs(s300)
        rust: bubble_rust(&s300)
        python: bubble_python(s300)
        csharp: BubbleCsharp(s300);
        c: bubble_c(s300, sizeof(s300))
    }

    bench n400 {
        go: bubbleGo(s400)
        ts: bubbleTs(s400)
        rust: bubble_rust(&s400)
        python: bubble_python(s400)
        csharp: BubbleCsharp(s400);
        c: bubble_c(s400, sizeof(s400))
    }

    bench n500 {
        go: bubbleGo(s500)
        ts: bubbleTs(s500)
        rust: bubble_rust(&s500)
        python: bubble_python(s500)
        csharp: BubbleCsharp(s500);
        c: bubble_c(s500, sizeof(s500))
    }

    bench n600 {
        go: bubbleGo(s600)
        ts: bubbleTs(s600)
        rust: bubble_rust(&s600)
        python: bubble_python(s600)
        csharp: BubbleCsharp(s600);
        c: bubble_c(s600, sizeof(s600))
    }

    bench n700 {
        go: bubbleGo(s700)
        ts: bubbleTs(s700)
        rust: bubble_rust(&s700)
        python: bubble_python(s700)
        csharp: BubbleCsharp(s700);
        c: bubble_c(s700, sizeof(s700))
    }

    bench n800 {
        go: bubbleGo(s800)
        ts: bubbleTs(s800)
        rust: bubble_rust(&s800)
        python: bubble_python(s800)
        csharp: BubbleCsharp(s800);
        c: bubble_c(s800, sizeof(s800))
    }

    bench n900 {
        go: bubbleGo(s900)
        ts: bubbleTs(s900)
        rust: bubble_rust(&s900)
        python: bubble_python(s900)
        csharp: BubbleCsharp(s900);
        c: bubble_c(s900, sizeof(s900))
    }

    bench n1000 {
        go: bubbleGo(s1000)
        ts: bubbleTs(s1000)
        rust: bubble_rust(&s1000)
        python: bubble_python(s1000)
        csharp: BubbleCsharp(s1000);
        c: bubble_c(s1000, sizeof(s1000))
    }

    after {
        charting.drawLineChart(
            title: "Bubble Sort - O(n²)",
            description: "Classic bubble sort - quadratic trend with regression + error overlays",
            output: "bubble-line-linear.svg",
            yScale: "linear",
            showStdDev: true,
            showErrorBars: true,
            showRegression: true,
            regressionModel: "auto",
        )
        charting.drawBarChart(
            title: "Bubble Sort - Grouped Bars",
            description: "Grouped bars per dataset size with statistical overlays",
            output: "bubble-bar-linear.svg",
            yScale: "linear",
            showStdDev: true,
            showErrorBars: true,
            showRegression: true,
            regressionModel: "auto",
        )
        charting.drawLineChart(
            title: "Bubble Sort - O(n²)",
            description: "Classic bubble sort - quadratic trend with regression + error overlays",
            output: "bubble-line-log10.svg",
            yScale: "log10",
            showStdDev: true,
            showErrorBars: true,
            showRegression: true,
            regressionModel: "auto",
        )
        charting.drawBarChart(
            title: "Bubble Sort - Grouped Bars",
            description: "Grouped bars per dataset size with statistical overlays",
            output: "bubble-bar-log10.svg",
            yScale: "log10",
            showStdDev: true,
            showErrorBars: true,
            showRegression: true,
            regressionModel: "auto",
        )
        charting.drawLineChart(
            title: "Bubble Sort - O(n²)",
            description: "Classic bubble sort - quadratic trend with regression + error overlays",
            output: "bubble-line-split.svg",
            yScale: "split",
            showStdDev: true,
            showErrorBars: true,
            showRegression: true,
            regressionModel: "auto",
        )
        charting.drawBarChart(
            title: "Bubble Sort - Grouped Bars",
            description: "Grouped bars per dataset size with statistical overlays",
            output: "bubble-bar-split.svg",
            yScale: "split",
            showStdDev: true,
            showErrorBars: true,
            showRegression: true,
            regressionModel: "auto",
        )
        charting.drawLineChart(
            title: "Bubble Sort - O(n²)",
            description: "Classic bubble sort - quadratic trend with regression + error overlays",
            output: "bubble-line-symlog.svg",
            yScale: "symlog",
            showStdDev: true,
            showErrorBars: true,
            showRegression: true,
            regressionModel: "auto",
        )
        charting.drawBarChart(
            title: "Bubble Sort - Grouped Bars",
            description: "Grouped bars per dataset size with statistical overlays",
            output: "bubble-bar-symlog.svg",
            yScale: "symlog",
            showStdDev: true,
            showErrorBars: true,
            showRegression: true,
            regressionModel: "auto",
        )
        charting.drawSpeedupChart(
            title: "String Concatenation - O(n²)",
            description: "Naive string concat s += 'x' - quadratic complexity",
            output: "cbubble-bar-speed.svg",
        )
    }
}
