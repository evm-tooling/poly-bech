use std::charting

suite bubbleN {
    description: "O(n^2) bubble sort on int32 array"
    warmup: 50
    compare: true
    baseline: "go"
    mode: "auto"
    targetTime: 100ms
    cvThreshold: 5
    count: 2
    memory: true

    setup go {
        import (
        "encoding/binary"
        )

        init {










        }

        helpers {
            func bubbleGo(data []byte) []byte {
                n := len(data) / 4
                arr := make([]int32, n)
                for i := 0; i < n; i++ {
                    arr[i] = int32(binary.BigEndian.Uint32(data[i*4 : (i+1)*4]))
                }
                for i := 0; i < n; i++ {
                    for j := 0; j < n-1-i; j++ {
                        if arr[j] > arr[j+1] {
                            arr[j], arr[j+1] = arr[j+1], arr[j]
                        }
                    }
                }
                out := make([]byte, len(data))
                for i := 0; i < n; i++ {
                    binary.BigEndian.PutUint32(out[i*4:(i+1)*4], uint32(arr[i]))
                }
                return out
            }
        }
    }

    setup ts {
        init {










        }

        helpers {
            function bubbleTs(data: Uint8Array): Uint8Array {
                const n = data.length / 4
                const arr = []
                for (let i = 0; i < n; i++) {
                    arr.push(data[i*4]<<24 | data[i*4+1]<<16 | data[i*4+2]<<8 | data[i*4+3])
                }
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n - 1 - i; j++) {
                        if (arr[j] > arr[j+1]) [arr[j], arr[j+1]] = [arr[j+1], arr[j]]
                    }
                }
                const out = new Uint8Array(data.length)
                for (let i = 0; i < n; i++) {
                    const v = (arr[i] >>> 0)
                    out[i*4] = (v>>24)&0xff; out[i*4+1] = (v>>16)&0xff
                    out[i*4+2] = (v>>8)&0xff; out[i*4+3] = v&0xff
                }
                return out
            }
        }
    }

    setup rust {
        init {










        }

        helpers {
            fn bubble_rust(data: &[u8]) -> Vec<u8> {
                let n = data.len() / 4;
                let mut arr: Vec<i32> = (0..n).map(|i| {
                    let j = i * 4;
                    i32::from_be_bytes([data[j], data[j+1], data[j+2], data[j+3]])
                }).collect();
                for i in 0..n {
                    for j in 0..n-1-i {
                        if arr[j] > arr[j+1] {
                            arr.swap(j, j+1);
                        }
                    }
                }
                let mut out = vec![0u8; data.len()];
                for (i, &v) in arr.iter().enumerate() {
                    out[i*4..(i+1)*4].copy_from_slice(&v.to_be_bytes());
                }
                out
            }
        }
    }

    fixture s100 {
        hex: @file("fixtures/sort/sort_100.hex")
    }

    fixture s200 {
        hex: @file("fixtures/sort/sort_200.hex")
    }

    fixture s300 {
        hex: @file("fixtures/sort/sort_300.hex")
    }

    fixture s400 {
        hex: @file("fixtures/sort/sort_400.hex")
    }

    fixture s500 {
        hex: @file("fixtures/sort/sort_500.hex")
    }

    fixture s600 {
        hex: @file("fixtures/sort/sort_600.hex")
    }

    fixture s700 {
        hex: @file("fixtures/sort/sort_700.hex")
    }

    fixture s800 {
        hex: @file("fixtures/sort/sort_800.hex")
    }

    fixture s900 {
        hex: @file("fixtures/sort/sort_900.hex")
    }

    fixture s1000 {
        hex: @file("fixtures/sort/sort_1000.hex")
    }

    bench n100 {
        go: bubbleGo(s100)
        ts: bubbleTs(s100)
        rust: bubble_rust(&s100)
    }

    bench n200 {
        go: bubbleGo(s200)
        ts: bubbleTs(s200)
        rust: bubble_rust(&s200)
    }

    bench n300 {
        go: bubbleGo(s300)
        ts: bubbleTs(s300)
        rust: bubble_rust(&s300)
    }

    bench n400 {
        go: bubbleGo(s400)
        ts: bubbleTs(s400)
        rust: bubble_rust(&s400)
    }

    bench n500 {
        go: bubbleGo(s500)
        ts: bubbleTs(s500)
        rust: bubble_rust(&s500)
    }

    bench n600 {
        go: bubbleGo(s600)
        ts: bubbleTs(s600)
        rust: bubble_rust(&s600)
    }

    bench n700 {
        go: bubbleGo(s700)
        ts: bubbleTs(s700)
        rust: bubble_rust(&s700)
    }

    bench n800 {
        go: bubbleGo(s800)
        ts: bubbleTs(s800)
        rust: bubble_rust(&s800)
    }

    bench n900 {
        go: bubbleGo(s900)
        ts: bubbleTs(s900)
        rust: bubble_rust(&s900)
    }

    bench n1000 {
        go: bubbleGo(s1000)
        ts: bubbleTs(s1000)
        rust: bubble_rust(&s1000)
    }

    after {
        charting.drawLineChart(
            title: "Bubble Sort - O(nÂ²)",
            description: "Classic bubble sort - quadratic complexity comparison",
            output: "bubble-line.svg",
            xlabel: "Array Size (n elements)",
            ylabel: "Time (ns/op)",
             height: 460,
     width: 615,
            axisThickness: 1.5,
            showGrid: true,
            gridOpacity: 0.2,
            titleFontSize: 18,
            subtitleFontSize: 12,
            axisLabelFontSize: 12,
            tickLabelFontSize: 10,
            legendPosition: "top-left",
            showErrorBars: true,
            errorBarOpacity: 0.4,
            errorBarThickness: 1.5,
            showRegression: true,
            regressionStyle: "dotted",
            showRegressionLabel: true,
            timeUnit: "auto",
            roundTicks: true ,
            yScale: "log"

        )

        charting.drawBarChart(
            title: "Bubble Sort Comparison",
            description: "Vertical grouped bars - quadratic growth visible",
            output: "bubble-bar.svg",
            xlabel: "Array Size",
            ylabel: "Time (ns/op)",
                      height: 460,
     width: 550,
            axisThickness: 1.5,
            showGrid: true,
            gridOpacity: 0.15,
            titleFontSize: 18,
            subtitleFontSize: 12,
            axisLabelFontSize: 12,
            tickLabelFontSize: 10,
            legendPosition: "top-left",
            showErrorBars: true,
            errorBarOpacity: 0.4,
            errorBarThickness: 1.5,
            barWidth: 15,
            barGroupGap: 15,
            barWithinGroupGap: 1,
            timeUnit: "auto",
            roundTicks: true,
             showRegression: true,
            regressionStyle: "dotted",
            showRegressionLabel: true,
            yScale: "log",

        )
    }

}
