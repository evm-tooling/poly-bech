use std::charting

declare suite example performance timeBased sameDataset: false {
    description: "Comprehensive benchmark showcasing all DSL features"
    warmup: 10
    baseline: "go"
    targetTime: 5000ms
    cvThreshold: 10
    count: 10

    setup go {
        import (
            "crypto/sha256"
            "sync"
            "github.com/ethereum/go-ethereum/common"
            "github.com/ChefBingbong/viem-go/abi"
        )

        declare {
            var benchERC20ABI *abi.ABI
            var balanceOfAddr = common.HexToAddress("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045")
            var setupCounter int
            var mu sync.Mutex
            var allocBuf []byte
        }

        init {
            var err error
            benchERC20ABI, err = abi.Parse([]byte(`[
            {"name":"name","type":"function","inputs":[],"outputs":[{"type":"string"}],"stateMutability":"view"},
            {"name":"symbol","type":"function","inputs":[],"outputs":[{"type":"string"}],"stateMutability":"view"},
            {"name":"decimals","type":"function","inputs":[],"outputs":[{"type":"uint8"}],"stateMutability":"view"},
            {"name":"totalSupply","type":"function","inputs":[],"outputs":[{"type":"uint256"}],"stateMutability":"view"},
            {"name":"balanceOf","type":"function","inputs":[{"name":"owner","type":"address"}],"outputs":[{"type":"uint256"}],"stateMutability":"view"},
            {"name":"allowance","type":"function","inputs":[{"name":"owner","type":"address"},{"name":"spender","type":"address"}],"outputs":[{"type":"uint256"}],"stateMutability":"view"},
            {"name":"transfer","type":"function","inputs":[{"name":"to","type":"address"},{"name":"amount","type":"uint256"}],"outputs":[{"type":"bool"}],"stateMutability":"nonpayable"},
            {"name":"approve","type":"function","inputs":[{"name":"spender","type":"address"},{"name":"amount","type":"uint256"}],"outputs":[{"type":"bool"}],"stateMutability":"nonpayable"},
            {"name":"transferFrom","type":"function","inputs":[{"name":"from","type":"address"},{"name":"to","type":"address"},{"name":"amount","type":"uint256"}],"outputs":[{"type":"bool"}],"stateMutability":"nonpayable"}
            ]`))
            if err != nil {
                panic("failed to parse ERC20 ABI for benchmarks: " + err.Error())
            }
        }

        helpers {
            func mustEncodeBalanceOf(addr common.Address) []byte {
                data, err := benchERC20ABI.EncodeFunctionData("balanceOf", addr)
                if err != nil {
                    panic(err)
                }
                return data
            }

            func sha256SumGo(data []byte) [32]byte {
                return sha256.Sum256(data)
            }

            func sha256SumGo1(data float64) float64 {
                return data * 3
            }

            func incrementCounter() {
                mu.Lock()
                setupCounter++
                mu.Unlock()
            }

            func resetCounter() {
                mu.Lock()
                setupCounter = 0
                mu.Unlock()
            }

            func allocateMemory(size int) []byte {
                return make([]byte, size)
            }
        }
    }

    setup ts {
        import {
            import { createHash } from 'node:crypto';
            import {
            encodeFunctionData,
            parseAbi,
            type Address,
            type Abi
            } from 'viem'
        }

        declare {
            let setupCounter = 0;
            let allocBuf: Uint8Array | null = null;
            const VITALIK = '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045' as Address
            const erc20Abi = parseAbi([
            'function name() view returns (string)',
            'function symbol() view returns (string)',
            'function decimals() view returns (uint8)',
            'function totalSupply() view returns (uint256)',
            'function balanceOf(address owner) view returns (uint256)',
            'function allowance(address owner, address spender) view returns (uint256)',
            'function transfer(address to, uint256 amount) returns (bool)',
            'function approve(address spender, uint256 amount) returns (bool)',
            'function transferFrom(address from, address to, uint256 amount) returns (bool)',
            ]) 

        }

        helpers {
            function sha256SumTs(data: Uint8Array): Buffer {
                return createHash('sha256').update(Buffer.from(data)).digest()
            }

            function incrementCounter(): void {
                setupCounter++;
            }

            function resetCounter(): void {
                setupCounter = 0;
            }

            function allocateMemory(size: number): Uint8Array {
                return new Uint8Array(size);
            }

            function encodeTs() {
                return encodeFunctionData({
                    abi: erc20Abi,
                    functionName: 'balanceOf',
                    args: [VITALIK],
                })
            }
        }
    }

    fixture data {
        hex: "68656c6c6f20776f726c64"
    }

    bench auto_mode_example {
        description: "Auto mode with 3 second target time"
        targetTime: 2000ms
        sink: true
        go: mustEncodeBalanceOf(balanceOfAddr)
        ts: encodeTs()
    }

    bench fixed_mode_example {
        description: "Fixed mode with explicit iteration count"
        warmup: 1000
        sink: true
        go: sha256SumGo(data)
        ts: sha256SumTs(data)
    }

    bench sink_enabled_example {
        description: "Benchmark with sink pattern enabled"
        targetTime: 2000ms
        sink: true
        go: sha256SumGo(data)
        ts: sha256SumTs(data)
    }

    bench sink_disabled_example {
        description: "Benchmark with sink pattern disabled"
        targetTime: 2000ms
        sink: false
        go: {
            incrementCounter()
        }
        ts: {
            incrementCounter()
        }
    }


    bench concurrent_execution_example {
        description: "Fixed execution example"
        go: sha256SumGo(data)
        ts: sha256SumTs(data)
    }
    
    bench outlier_detection_example {
        description: "Benchmark with outlier detection enabled"
        targetTime: 2000ms
        outlierDetection: true
        go: sha256SumGo(data)
        ts: sha256SumTs(data)
    }

    bench cv_threshold_example {
        description: "Benchmark with strict CV threshold (5%)"
        targetTime: 2000ms
        outlierDetection: true
        cvThreshold: 5
        go: sha256SumGo(data)
        ts: sha256SumTs(data)
    }

    bench iteration_bounds_example {
        description: "Auto mode iteration example"
        targetTime: 2000ms
        go: sha256SumGo(data)
        ts: sha256SumTs(data)
    }

    bench lifecycle_hooks_example {
        description: "Benchmark with before, after, and each hooks"
        warmup: 100
        before ts: resetCounter()
        before go: resetCounter()
        after ts: {
            void setupCounter 
        }
        after go: {
            _ = setupCounter 
        }
        each go: incrementCounter()
        each ts: incrementCounter()
        go: sha256SumGo(data)
        ts: sha256SumTs(data)
    }

    after {
        charting.drawTable(
            title: "Performance Comparison",
            description: "Go vs TypeScript Benchmark Results",
            sortBy: "speedup",
            sortOrder: "desc",
        )
        charting.drawSpeedupChart(
            title: "Performance Trends",
            description: "Timing across all benchmarks",
        )
        charting.drawTable(
            title: "Detailed Results",
            description: "Relative time spent in each benchmark",
        )
    }
}
