use std::constants
use std::charting

suite example {
    description: "Comprehensive benchmark showcasing all DSL features"
    warmup: 0
    compare: true
    baseline: "go"
    mode: "auto"
    targetTime: 5000ms
    minIterations: 1000
    maxIterations: 10000000
    cvThreshold: 10
    count: 10

    setup go {
        import (
        "crypto/sha256"
        "sync"
        "github.com/ethereum/go-ethereum/common"
        "github.com/ChefBingbong/viem-go/abi"
        )

        declare {
            var benchERC20ABI *abi.ABI
            var balanceOfAddr = common.HexToAddress("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045")
            var x float64 = std_PI
            var setupCounter int
            var mu sync.Mutex
            var allocBuf []byte
        }

        init {
            var err error
            benchERC20ABI, err = abi.Parse([]byte(`[
                {"name":"name","type":"function","inputs":[],"outputs":[{"type":"string"}],"stateMutability":"view"},
                {"name":"symbol","type":"function","inputs":[],"outputs":[{"type":"string"}],"stateMutability":"view"},
                {"name":"decimals","type":"function","inputs":[],"outputs":[{"type":"uint8"}],"stateMutability":"view"},
                {"name":"totalSupply","type":"function","inputs":[],"outputs":[{"type":"uint256"}],"stateMutability":"view"},
                {"name":"balanceOf","type":"function","inputs":[{"name":"owner","type":"address"}],"outputs":[{"type":"uint256"}],"stateMutability":"view"},
                {"name":"allowance","type":"function","inputs":[{"name":"owner","type":"address"},{"name":"spender","type":"address"}],"outputs":[{"type":"uint256"}],"stateMutability":"view"},
                {"name":"transfer","type":"function","inputs":[{"name":"to","type":"address"},{"name":"amount","type":"uint256"}],"outputs":[{"type":"bool"}],"stateMutability":"nonpayable"},
                {"name":"approve","type":"function","inputs":[{"name":"spender","type":"address"},{"name":"amount","type":"uint256"}],"outputs":[{"type":"bool"}],"stateMutability":"nonpayable"},
                {"name":"transferFrom","type":"function","inputs":[{"name":"from","type":"address"},{"name":"to","type":"address"},{"name":"amount","type":"uint256"}],"outputs":[{"type":"bool"}],"stateMutability":"nonpayable"}
            ]`))
            if err != nil {
                panic("failed to parse ERC20 ABI for benchmarks: " + err.Error())
            }
        }

        helpers {
            func mustEncodeBalanceOf(addr common.Address) []byte {
                data, err := benchERC20ABI.EncodeFunctionData("balanceOf", addr)
                if err != nil {
                    panic(err)
                }
                return data
            }

            func sha256SumGo(data []byte) [32]byte {
                return sha256.Sum256(data)
            }

            func sha256SumGo1(data float64) float64 {
                return data * x
            }

            func incrementCounter() {
                mu.Lock()
                setupCounter++
                mu.Unlock()
            }

            func resetCounter() {
                mu.Lock()
                setupCounter = 0
                mu.Unlock()
            }

            func allocateMemory(size int) []byte {
                return make([]byte, size)
            }
        }
    }

    setup ts {
        import {
            import { createHash } from 'node:crypto';
            import {
                encodeFunctionData,
                parseAbi,
            } from 'viem'
        }

        declare {
            let setupCounter = 0;
            let allocBuf: Uint8Array | null = null;
            const erc20Abi = parseAbi([
                'function name() view returns (string)',
                'function symbol() view returns (string)',
                'function decimals() view returns (uint8)',
                'function totalSupply() view returns (uint256)',
                'function balanceOf(address owner) view returns (uint256)',
                'function allowance(address owner, address spender) view returns (uint256)',
                'function transfer(address to, uint256 amount) returns (bool)',
                'function approve(address spender, uint256 amount) returns (bool)',
                'function transferFrom(address from, address to, uint256 amount) returns (bool)',
            ])

            const VITALIK = '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'
        }

        init {





        }

        helpers {
            function sha256SumTs(data: Uint8Array): Buffer {
                return createHash('sha256').update(Buffer.from(data)).digest()
            }

            function incrementCounter(): void {
                setupCounter++;
            }

            function resetCounter(): void {
                setupCounter = 0;
            }

            function allocateMemory(size: number): Uint8Array {
                return new Uint8Array(size);
            }
        }
    }

    fixture data {
        hex: "68656c6c6f20776f726c64"
    }

    # Comprehensive example benchmark demonstrating all unique DSL configuration settings
    # This file showcases: mode, targetTime, iterations, warmup, sink, memory, concurrency,
    # outlierDetection, cvThreshold, minIterations, maxIterations, and lifecycle hooks





















    # ============================================================================
    # BENCHMARK MODE EXAMPLES
    # ============================================================================

    # Auto mode: Automatically calibrates iterations to reach targetTime
    # Uses adaptive batch scaling like Go's testing.B
    bench auto_mode_example {
        description: "Auto mode with 3 second target time"
        mode: "auto"
        targetTime: 2000ms
        sink: true
        go: mustEncodeBalanceOf(balanceOfAddr)
        ts: {
            encodeFunctionData({
                abi: erc20Abi,
                functionName: 'balanceOf',
                args: [VITALIK],
            })
        }
    }

    # Fixed mode: Runs exactly the specified number of iterations
    # Good for reproducible benchmarks with known iteration counts
    bench fixed_mode_example {
        description: "Fixed mode with explicit iteration count"
        iterations: 100000
        warmup: 1000
        mode: "fixed"
        sink: true
        go: sha256SumGo(data)
        ts: sha256SumTs(data)
    }

    # ============================================================================
    # SINK PATTERN EXAMPLES
    # ============================================================================

    # Sink enabled: Assigns result to a global variable to prevent DCE
    # Use when the compiler might optimize away unused return values
    bench sink_enabled_example {
        description: "Benchmark with sink pattern enabled"
        mode: "auto"
        targetTime: 2000ms
        sink: false
        go: sha256SumGo(data)
        ts: sha256SumTs(data)
    }

    # Sink disabled: Does not capture return value
    # Use for functions with side effects or when DCE is not a concern
    bench sink_disabled_example {
        description: "Benchmark with sink pattern disabled"
        mode: "auto"
        targetTime: 2000ms
        sink: false
        go: {
            incrementCounter()
        }
        ts: {
            incrementCounter()
        }
    }

    # ============================================================================
    # MEMORY PROFILING EXAMPLES (Phase 2B)
    # ============================================================================

    # Memory profiling tracks heap allocations using:
    # - Go: runtime.ReadMemStats (BytesPerOp, AllocsPerOp)
    # - TypeScript: process.memoryUsage().heapUsed
    bench memory_profiling_example {
        description: "Benchmark with memory profiling enabled"
        mode: "auto"
        targetTime: 2000ms
        memory: true
        go: allocateMemory(1024)
        ts: allocateMemory(1024)
    }

    # ============================================================================
    # CONCURRENT EXECUTION EXAMPLES (Phase 2B - Go only)
    # ============================================================================

    # Concurrent benchmark splits iterations across multiple goroutines
    # Useful for testing thread-safe code or parallel workloads
    bench concurrent_execution_example {
        description: "Concurrent execution with 4 goroutines"
        iterations: 100000
        mode: "fixed"
        concurrency: 1
        go: sha256SumGo(data)
        ts: sha256SumTs(data)
    }

    # Combined memory profiling and concurrent execution
    bench concurrent_with_memory {
        description: "Concurrent execution with memory profiling"
        iterations: 50000
        mode: "fixed"
        memory: true
        concurrency: 1
        go: allocateMemory(512)
        ts: allocateMemory(512)
    }

    # ============================================================================
    # STATISTICAL ANALYSIS EXAMPLES
    # ============================================================================

    # Outlier detection removes statistical outliers from measurements
    # Helps produce more stable and representative results
    bench outlier_detection_example {
        description: "Benchmark with outlier detection enabled"
        mode: "auto"
        targetTime: 2000ms
        outlierDetection: true
        go: sha256SumGo(data)
        ts: sha256SumTs(data)
    }

    # CV threshold sets the coefficient of variation stability target
    # Lower values require more stable measurements before stopping
    bench cv_threshold_example {
        description: "Benchmark with strict CV threshold (5%)"
        mode: "auto"
        targetTime: 2000ms
        outlierDetection: true
        cvThreshold: 5
        go: sha256SumGo(data)
        ts: sha256SumTs(data)
    }

    # ============================================================================
    # ITERATION BOUNDS EXAMPLES
    # ============================================================================

    # Min/max iterations constrain auto mode's iteration selection
    # Ensures benchmarks run within reasonable bounds
    bench iteration_bounds_example {
        description: "Auto mode with min/max iteration bounds"
        mode: "auto"
        targetTime: 2000ms
        minIterations: 5000
        maxIterations: 500000
        go: sha256SumGo(data)
        ts: sha256SumTs(data)
    }

    # ============================================================================
    # LIFECYCLE HOOKS EXAMPLES
    # ============================================================================

    # Before/after hooks run once per benchmark (setup/teardown)
    # Each hook runs before every iteration (reset state)
    bench lifecycle_hooks_example {
        description: "Benchmark with before, after, and each hooks"
        iterations: 10000
        warmup: 100
        mode: "fixed"

        before: {
            go: resetCounter()
            ts: resetCounter()
        }

        each: {
            go: incrementCounter()
            ts: incrementCounter()
        }
        go: sha256SumGo(data)
        ts: sha256SumTs(data)

        after: {
            go: {
                _ = setupCounter 
            }
            ts: {
                void setupCounter 
            }
        }
    }

    after {
        charting.drawBarChart(
            title: "Performance Comparison",
            description: "Go vs TypeScript Benchmark Results",
            sortBy: "speedup",
            sortOrder: "desc"
        )

        charting.drawLineChart(
            title: "Performance Trends",
            description: "Timing across all benchmarks",
            xlabel: "Benchmark",
            ylabel: "Time",
            timeUnit: "auto"
        )

        charting.drawPieChart(
            title: "Time Distribution",
            description: "Relative time spent in each benchmark",
            showTotalTime: true
        )
    }

}
