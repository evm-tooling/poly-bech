use std::charting

suite example {
    description: "Comprehensive benchmark showcasing all DSL features"
    warmup: 0
    compare: true
    baseline: "go"
    mode: "auto"
    targetTime: 5000ms
    minIterations: 1000
    maxIterations: 10000000
    cvThreshold: 10
    count: 10

    setup go {
        import (
            "crypto/sha256"
            "sync"
            "github.com/ethereum/go-ethereum/common"
            "github.com/ChefBingbong/viem-go/abi"
        )

        declare {
            var benchERC20ABI *abi.ABI
            var balanceOfAddr = common.HexToAddress("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045")
            var setupCounter int
            var mu sync.Mutex
            var allocBuf []byte
        }

        init {
            var err error
            benchERC20ABI, err = abi.Parse([]byte(`[
                {"name":"name","type":"function","inputs":[],"outputs":[{"type":"string"}],"stateMutability":"view"},
                {"name":"symbol","type":"function","inputs":[],"outputs":[{"type":"string"}],"stateMutability":"view"},
                {"name":"decimals","type":"function","inputs":[],"outputs":[{"type":"uint8"}],"stateMutability":"view"},
                {"name":"totalSupply","type":"function","inputs":[],"outputs":[{"type":"uint256"}],"stateMutability":"view"},
                {"name":"balanceOf","type":"function","inputs":[{"name":"owner","type":"address"}],"outputs":[{"type":"uint256"}],"stateMutability":"view"},
                {"name":"allowance","type":"function","inputs":[{"name":"owner","type":"address"},{"name":"spender","type":"address"}],"outputs":[{"type":"uint256"}],"stateMutability":"view"},
                {"name":"transfer","type":"function","inputs":[{"name":"to","type":"address"},{"name":"amount","type":"uint256"}],"outputs":[{"type":"bool"}],"stateMutability":"nonpayable"},
                {"name":"approve","type":"function","inputs":[{"name":"spender","type":"address"},{"name":"amount","type":"uint256"}],"outputs":[{"type":"bool"}],"stateMutability":"nonpayable"},
                {"name":"transferFrom","type":"function","inputs":[{"name":"from","type":"address"},{"name":"to","type":"address"},{"name":"amount","type":"uint256"}],"outputs":[{"type":"bool"}],"stateMutability":"nonpayable"}
            ]`))
            if err != nil {
                panic("failed to parse ERC20 ABI for benchmarks: " + err.Error())
            }
        }

        helpers {
            func mustEncodeBalanceOf(addr common.Address) []byte {
                data, err := benchERC20ABI.EncodeFunctionData("balanceOf", addr)
                if err != nil {
                    panic(err)
                }
                return data
            }

            func sha256SumGo(data []byte) [32]byte {
                return sha256.Sum256(data)
            }

            func sha256SumGo1(data float64) float64 {
                return data * 3
            }

            func incrementCounter() {
                mu.Lock()
                setupCounter++
                mu.Unlock()
            }

            func resetCounter() {
                mu.Lock()
                setupCounter = 0
                mu.Unlock()
            }

            func allocateMemory(size int) []byte {
                return make([]byte, size)
            }
        }
    }

    setup ts {
        import {
            import { createHash } from 'node:crypto';
            import {
            encodeFunctionData,
            parseAbi,
            } from 'viem'
        }

        declare {
            let setupCounter = 0;
            let allocBuf: Uint8Array | null = null;
            const erc20Abi = parseAbi([
                'function name() view returns (string)',
                'function symbol() view returns (string)',
                'function decimals() view returns (uint8)',
                'function totalSupply() view returns (uint256)',
                'function balanceOf(address owner) view returns (uint256)',
                'function allowance(address owner, address spender) view returns (uint256)',
                'function transfer(address to, uint256 amount) returns (bool)',
                'function approve(address spender, uint256 amount) returns (bool)',
                'function transferFrom(address from, address to, uint256 amount) returns (bool)',
            ])

            const VITALIK = '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'
        }

        helpers {
            function sha256SumTs(data: Uint8Array): Buffer {
                return createHash('sha256').update(Buffer.from(data)).digest()
            }

            function incrementCounter(): void {
                setupCounter++;
            }

            function resetCounter(): void {
                setupCounter = 0;
            }

            function allocateMemory(size: number): Uint8Array {
                return new Uint8Array(size);
            }

            function encodeTs() {
                return encodeFunctionData({
                abi: erc20Abi,
                functionName: 'balanceOf',
                args: [VITALIK],
            })
            }
        }
    }

    fixture data {
        hex: "68656c6c6f20776f726c64"
    }

    bench auto_mode_example {
        description: "Auto mode with 3 second target time"
        mode: "auto"
        targetTime: 2000ms
        sink: true
        go: mustEncodeBalanceOf(balanceOfAddr)
        ts: encodeTs()
    }

    bench fixed_mode_example {
        description: "Fixed mode with explicit iteration count"
        iterations: 100000
        warmup: 1000
        mode: "fixed"
        sink: true
        go: sha256SumGo(data)
        ts: sha256SumTs(data)
    }

    bench sink_enabled_example {
        description: "Benchmark with sink pattern enabled"
        mode: "auto"
        targetTime: 2000ms
        sink: false
        go: sha256SumGo(data)
        ts: sha256SumTs(data)
    }

    bench sink_disabled_example {
        description: "Benchmark with sink pattern disabled"
        mode: "auto"
        targetTime: 2000ms
        sink: false
        go: {
            incrementCounter()
        }
        ts: {
            incrementCounter()
        }
    }

    bench memory_profiling_example {
        description: "Benchmark with memory profiling enabled"
        mode: "auto"
        targetTime: 2000ms
        memory: true
        go: allocateMemory(1024)
        ts: allocateMemory(1024)
    }

    bench concurrent_execution_example {
        description: "Concurrent execution with 4 goroutines"
        iterations: 100000
        mode: "fixed"
        concurrency: 1
        go: sha256SumGo(data)
        ts: sha256SumTs(data)
    }

    bench concurrent_with_memory {
        description: "Concurrent execution with memory profiling"
        iterations: 50000
        mode: "fixed"
        memory: true
        concurrency: 1
        go: allocateMemory(512)
        ts: allocateMemory(512)
    }

    bench outlier_detection_example {
        description: "Benchmark with outlier detection enabled"
        mode: "auto"
        targetTime: 2000ms
        outlierDetection: true
        go: sha256SumGo(data)
        ts: sha256SumTs(data)
    }

    bench cv_threshold_example {
        description: "Benchmark with strict CV threshold (5%)"
        mode: "auto"
        targetTime: 2000ms
        outlierDetection: true
        cvThreshold: 5
        go: sha256SumGo(data)
        ts: sha256SumTs(data)
    }

    bench iteration_bounds_example {
        description: "Auto mode with min/max iteration bounds"
        mode: "auto"
        targetTime: 2000ms
        minIterations: 5000
        maxIterations: 500000
        go: sha256SumGo(data)
        ts: sha256SumTs(data)
    }

    bench lifecycle_hooks_example {
        description: "Benchmark with before, after, and each hooks"
        iterations: 10000
        warmup: 100
        mode: "fixed"
        before go: resetCounter()
        before ts: resetCounter()
        after ts: {
            void setupCounter 
        }
        after go: {
            _ = setupCounter 
        }
        each go: incrementCounter()
        each ts: incrementCounter()
        go: sha256SumGo(data)
        ts: sha256SumTs(data)
    }

    after {
        charting.drawBarChart(
            title: "Performance Comparison",
            description: "Go vs TypeScript Benchmark Results",
            sortBy: "speedup",
            sortOrder: "desc",
        )
        charting.drawLineChart(
            title: "Performance Trends",
            description: "Timing across all benchmarks",
            xlabel: "Benchmark",
            ylabel: "Time",
            timeUnit: "auto",
        )
        charting.drawPieChart(
            title: "Time Distribution",
            description: "Relative time spent in each benchmark",
            showTotalTime: true,
        )
    }
}
