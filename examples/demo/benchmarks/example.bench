use std::constants
use std::charting

suite example {
    description: "Example benchmark showcasing auto-calibration, sink patterns, statistical analysis, and lifecycle hooks"
    warmup: 0
    compare: true
    baseline: "go"
    mode: "auto"
    targetTime: 30000ms
    minIterations: 10000
    maxIterations: 1000000
    sink: false
    outlierDetection: false
    cvThreshold: 5

    setup go {
        import (
            "crypto/sha256"
            "sync"
            "github.com/ethereum/go-ethereum/common"
            "github.com/ChefBingbong/viem-go/abi"
        )

        declare {
            var benchERC20ABI *abi.ABI
        var balanceOfAddr = common.HexToAddress("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045")
            var x float64 = std_PI
            var setupCounter int
            var mu sync.Mutex
        }

        init {
             var err error
            benchERC20ABI, err = abi.Parse([]byte(`[
                {"name":"name","type":"function","inputs":[],"outputs":[{"type":"string"}],"stateMutability":"view"},
                {"name":"symbol","type":"function","inputs":[],"outputs":[{"type":"string"}],"stateMutability":"view"},
                {"name":"decimals","type":"function","inputs":[],"outputs":[{"type":"uint8"}],"stateMutability":"view"},
                {"name":"totalSupply","type":"function","inputs":[],"outputs":[{"type":"uint256"}],"stateMutability":"view"},
                {"name":"balanceOf","type":"function","inputs":[{"name":"owner","type":"address"}],"outputs":[{"type":"uint256"}],"stateMutability":"view"},
                {"name":"allowance","type":"function","inputs":[{"name":"owner","type":"address"},{"name":"spender","type":"address"}],"outputs":[{"type":"uint256"}],"stateMutability":"view"},
                {"name":"transfer","type":"function","inputs":[{"name":"to","type":"address"},{"name":"amount","type":"uint256"}],"outputs":[{"type":"bool"}],"stateMutability":"nonpayable"},
                {"name":"approve","type":"function","inputs":[{"name":"spender","type":"address"},{"name":"amount","type":"uint256"}],"outputs":[{"type":"bool"}],"stateMutability":"nonpayable"},
                {"name":"transferFrom","type":"function","inputs":[{"name":"from","type":"address"},{"name":"to","type":"address"},{"name":"amount","type":"uint256"}],"outputs":[{"type":"bool"}],"stateMutability":"nonpayable"}
            ]`))
            if err != nil {
                panic("failed to parse ERC20 ABI for benchmarks: " + err.Error())
            }
        }

        helpers {
             func mustEncodeBalanceOf(addr common.Address) []byte {
            data, err := benchERC20ABI.EncodeFunctionData("balanceOf", addr)
            if err != nil {
                panic(err)
            }
            return data
        }
            func sha256SumGo(data []byte) [32]byte {
                return sha256.Sum256(data)
            }

            func sha256SumGo1(data float64) float64 {
                return data * x
            }

            func incrementCounter() {
                mu.Lock()
                setupCounter++
                mu.Unlock()
            }

            func resetCounter() {
                mu.Lock()
                setupCounter = 0
                mu.Unlock()
            }
        }
    }

    setup ts {
        import {
            import { createHash } from 'node:crypto';
            import {
            encodeFunctionData,
            parseAbi,
        } from 'viem'
        }

        declare {
            let setupCounter = 0;
            const erc20Abi = parseAbi([
            'function name() view returns (string)',
            'function symbol() view returns (string)',
            'function decimals() view returns (uint8)',
            'function totalSupply() view returns (uint256)',
            'function balanceOf(address owner) view returns (uint256)',
            'function allowance(address owner, address spender) view returns (uint256)',
            'function transfer(address to, uint256 amount) returns (bool)',
            'function approve(address spender, uint256 amount) returns (bool)',
            'function transferFrom(address from, address to, uint256 amount) returns (bool)',
        ])

        const VITALIK = '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045' 
        }

        init {
            
        }

        helpers {
            function sha256SumTs(data: Uint8Array): Buffer {
                return createHash('sha256').update(Buffer.from(data)).digest()
            }

            function incrementCounter(): void {
                setupCounter++;
            }

            function resetCounter(): void {
                setupCounter = 0;
            }
        }
    }

    fixture data {
        hex: "68656c6c6f20776f726c64"
    }

    # Auto mode with 3s target time (quick benchmark)
    bench sha256_auto_3s {
        description: "SHA256 with auto mode, 3 second target"
        mode: auto
        targetTime: 30000
        sink: true
        go:  mustEncodeBalanceOf(balanceOfAddr)
        ts:  {
            encodeFunctionData({
                abi: erc20Abi,
                functionName: 'balanceOf',
                args: [VITALIK],
            })
        }
    }

   

    after {
        charting.drawBarChart(
            title: "Performance Comparison",
            description: "Go vs TypeScript SHA256 Benchmarks",
            sortBy: "speedup",
            sortOrder: "desc"
        )

        charting.drawLineChart(
            title: "Performance Trends",
            description: "Go vs TypeScript over benchmarks",
            xlabel: "Benchmark",
            ylabel: "Time",
            timeUnit: "auto"
        )

        charting.drawPieChart(
            title: "Time Distribution",
            description: "Relative time spent in each benchmark",
            showTotalTime: true
        )
    }

}
