//! Go plugin source code generation

use crate::dsl::Lang;
use crate::ir::{BenchmarkIR, SuiteIR, BenchmarkSpec, FixtureIR};
use crate::stdlib;
use miette::{Result, miette};

/// Generate Go plugin source code from IR
pub fn generate(ir: &BenchmarkIR) -> Result<String> {
    let mut code = String::new();

    // Package declaration
    code.push_str("// Code generated by poly-bench. DO NOT EDIT.\n\npackage main\n\n");
    
    // Collect all user imports from all suites
    let mut user_imports: Vec<&str> = Vec::new();
    for suite in &ir.suites {
        if let Some(imports) = suite.imports.get(&Lang::Go) {
            for import_spec in imports {
                user_imports.push(import_spec);
            }
        }
    }
    
    // Generate unified import block
    code.push_str("import (\n");
    code.push_str("\t\"encoding/json\"\n");
    code.push_str("\t\"time\"\n");
    for import_spec in &user_imports {
        code.push_str(&format!("\t{}\n", import_spec));
    }
    code.push_str(")\n\n");

    // Inject stdlib code if any modules are imported
    let stdlib_code = stdlib::get_stdlib_code(&ir.stdlib_imports, Lang::Go);
    if !stdlib_code.is_empty() {
        code.push_str(&stdlib_code);
        code.push_str("\n");
    }

    // BenchResult type
    code.push_str(r#"// BenchResult holds the benchmark measurement results
type BenchResult struct {
	Iterations  uint64   `json:"iterations"`
	TotalNanos  uint64   `json:"total_nanos"`
	NanosPerOp  float64  `json:"nanos_per_op"`
	OpsPerSec   float64  `json:"ops_per_sec"`
	BytesPerOp  uint64   `json:"bytes_per_op"`
	AllocsPerOp uint64   `json:"allocs_per_op"`
	Samples     []uint64 `json:"samples,omitempty"`
}

// Export symbols for plugin loading
var (
	RunBenchmark  = runBenchmark
	ListBenchmarks = listBenchmarks
)

"#);

    // Generate code for each suite
    for suite in &ir.suites {
        generate_suite(&mut code, suite)?;
    }

    // Generate the main runner function
    code.push_str(r#"
// runBenchmark executes a benchmark by name and returns JSON results
func runBenchmark(name string, iterations int) string {
	var result BenchResult

	switch name {
"#);

    for suite in &ir.suites {
        for bench in &suite.benchmarks {
            if bench.has_lang(Lang::Go) {
                code.push_str(&format!(
                    "\tcase \"{}\":\n\t\tresult = bench_{}(iterations)\n",
                    bench.full_name, bench.full_name
                ));
            }
        }
    }

    code.push_str(r#"	default:
		result = BenchResult{}
	}

	jsonBytes, _ := json.Marshal(result)
	return string(jsonBytes)
}

// listBenchmarks returns a JSON array of available benchmark names
func listBenchmarks() string {
	names := []string{
"#);

    for suite in &ir.suites {
        for bench in &suite.benchmarks {
            if bench.has_lang(Lang::Go) {
                code.push_str(&format!("\t\t\"{}\",\n", bench.full_name));
            }
        }
    }

    code.push_str(r#"	}
	jsonBytes, _ := json.Marshal(names)
	return string(jsonBytes)
}

func main() {}
"#);

    Ok(code)
}

/// Generate code for a single suite
fn generate_suite(code: &mut String, suite: &SuiteIR) -> Result<()> {
    // Add declarations
    if let Some(declarations) = suite.declarations.get(&Lang::Go) {
        if !declarations.trim().is_empty() {
            code.push_str("// Declarations\n");
            code.push_str(declarations);
            code.push_str("\n\n");
        }
    }

    // Add init function if present
    if let Some(init_code) = suite.init_code.get(&Lang::Go) {
        if !init_code.trim().is_empty() {
            code.push_str("func init() {\n");
            code.push_str(init_code);
            code.push_str("\n}\n\n");
        }
    }

    // Add helpers
    if let Some(helpers) = suite.helpers.get(&Lang::Go) {
        if !helpers.trim().is_empty() {
            code.push_str("// Helpers\n");
            code.push_str(helpers);
            code.push_str("\n\n");
        }
    }

    // Generate fixtures
    for fixture in &suite.fixtures {
        generate_fixture(code, fixture)?;
    }

    // Generate benchmark functions
    for bench in &suite.benchmarks {
        if bench.has_lang(Lang::Go) {
            generate_benchmark(code, bench, suite)?;
        }
    }

    Ok(())
}

/// Generate a fixture variable
fn generate_fixture(code: &mut String, fixture: &FixtureIR) -> Result<()> {
    // Check if there's a Go-specific implementation
    if let Some(impl_code) = fixture.implementations.get(&Lang::Go) {
        code.push_str(&format!("// Fixture: {}\n", fixture.name));
        if let Some(ref desc) = fixture.description {
            code.push_str(&format!("// {}\n", desc));
        }
        code.push_str(&format!("var {} = {}\n\n", fixture.name, impl_code));
    } else if !fixture.data.is_empty() {
        // Use hex data as byte slice
        code.push_str(&format!("// Fixture: {}\n", fixture.name));
        if let Some(ref desc) = fixture.description {
            code.push_str(&format!("// {}\n", desc));
        }
        code.push_str(&format!("var {} = {}\n\n", fixture.name, fixture.as_go_bytes()));
    }

    Ok(())
}

/// Generate a benchmark function
fn generate_benchmark(code: &mut String, bench: &BenchmarkSpec, _suite: &SuiteIR) -> Result<()> {
    let impl_code = bench.get_impl(Lang::Go)
        .ok_or_else(|| miette!("No Go implementation for benchmark {}", bench.name))?;

    code.push_str(&format!("// Benchmark: {}\n", bench.name));
    if let Some(ref desc) = bench.description {
        code.push_str(&format!("// {}\n", desc));
    }

    code.push_str(&format!(r#"func bench_{}(iterations int) BenchResult {{
	samples := make([]uint64, iterations)
	
	// Warmup
	for i := 0; i < {}; i++ {{
		_ = {}
	}}
	
	// Timed run
	var totalNanos uint64
	for i := 0; i < iterations; i++ {{
		start := time.Now()
		_ = {}
		elapsed := time.Since(start).Nanoseconds()
		samples[i] = uint64(elapsed)
		totalNanos += uint64(elapsed)
	}}
	
	nanosPerOp := float64(totalNanos) / float64(iterations)
	opsPerSec := 1e9 / nanosPerOp
	
	return BenchResult{{
		Iterations:  uint64(iterations),
		TotalNanos:  totalNanos,
		NanosPerOp:  nanosPerOp,
		OpsPerSec:   opsPerSec,
		Samples:     samples,
	}}
}}

"#, bench.full_name, bench.warmup, impl_code, impl_code));

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::dsl::parse;
    use crate::ir::lower;

    #[test]
    fn test_generate_simple() {
        let source = r#"
suite hash {
    iterations: 1000
    warmup: 10
    
    fixture data {
        hex: "deadbeef"
    }
    
    bench keccak256 {
        go: keccak256(data)
    }
}
"#;
        let ast = parse(source, "test.bench").unwrap();
        let ir = lower(&ast, None).unwrap();
        let code = generate(&ir).unwrap();
        
        assert!(code.contains("package main"));
        assert!(code.contains("func bench_hash_keccak256"));
        assert!(code.contains("var data = []byte{0xde, 0xad, 0xbe, 0xef}"));
    }

    #[test]
    fn test_generate_with_stdlib_constants() {
        let source = r#"
use std::constants

suite math {
    iterations: 100
    
    bench pi_calc {
        go: compute(std_PI)
    }
}
"#;
        let ast = parse(source, "test.bench").unwrap();
        let ir = lower(&ast, None).unwrap();
        let code = generate(&ir).unwrap();
        
        // Verify stdlib constants are injected
        assert!(code.contains("std_PI"));
        assert!(code.contains("std_E"));
        assert!(code.contains("float64"));
        assert!(code.contains("3.14159"));
    }

    #[test]
    fn test_generate_without_stdlib() {
        let source = r#"
suite test {
    iterations: 100
    
    fixture data {
        hex: "deadbeef"
    }
    
    bench simple {
        go: test(data)
    }
}
"#;
        let ast = parse(source, "test.bench").unwrap();
        let ir = lower(&ast, None).unwrap();
        let code = generate(&ir).unwrap();
        
        // Should not contain stdlib constants
        assert!(!code.contains("std_PI"));
        assert!(!code.contains("std_E"));
    }
}
