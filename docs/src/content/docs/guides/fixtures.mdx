---
title: Fixtures Guide
description: How to define, load, and use test data fixtures in poly-bench
---

<div data-pagefind-weight="10">

Fixtures define shared test data that is passed to every language implementation in a benchmark. They guarantee that Go, TypeScript, and Rust all operate on identical bytes — a prerequisite for fair cross-language comparisons.

</div>

### How Fixtures Work

When poly-bench generates benchmark code, each fixture is decoded once and injected as a native byte array into the generated code for each language:

| Language | Type |
|----------|------|
| Go | `[]byte` |
| TypeScript | `Uint8Array` |
| Rust | `&[u8]` (slice reference) |

Fixtures are defined inside a `suite` block and are available to all `bench` blocks in that suite by name.

---

### Inline Hex Fixture

The simplest fixture: a hex-encoded string inlined directly in the `.bench` file. Use this for small, fixed test vectors.

<CodeGroup
  tabs={[
    {
      title: "bench",
      language: "bench",
      code: `fixture shortInput {
    hex: "68656c6c6f20776f726c64"   # "hello world" in UTF-8
}

fixture address {
    hex: "d8da6bf26964af9d7eed9e03e53415d37aa96045"   # 20-byte Ethereum address
}

fixture emptyInput {
    hex: ""   # zero-length byte slice
}`
    },
  ]}
/>

Using fixtures in bench blocks:

<CodeGroup
  tabs={[
    {
      title: "Go",
      language: "bench",
      code: `bench hashShort {
    go: keccak256Go(shortInput)     # shortInput is []byte
}`
    },
    {
      title: "TypeScript",
      language: "bench",
      code: `bench hashShort {
    ts: keccak256Ts(shortInput)     # shortInput is Uint8Array
}`
    },
    {
      title: "Rust",
      language: "bench",
      code: `bench hashShort {
    rust: keccak256_rust(&shortInput)   # shortInput is &[u8]
}`
    },
    {
      title: "All three",
      language: "bench",
      code: `bench hashShort {
    go: keccak256Go(shortInput)
    ts: keccak256Ts(shortInput)
    rust: keccak256_rust(&shortInput)
}`
    },
  ]}
/>

<Aside type="note">
<span>Rust benchmarks almost always need the <code>&</code> prefix when passing a fixture to a function that takes <code>&[u8]</code>. Go and TypeScript receive the value directly.</span>
</Aside>

---

### File-Referenced Fixture

For larger payloads, store the hex data in an external file and reference it with `@file(...)`. The path is relative to the `.bench` file's location.

<CodeGroup
  tabs={[
    {
      title: "bench",
      language: "bench",
      code: `fixture largePayload {
    hex: @file("fixtures/keccak/input_1024.hex")
}

fixture sortData {
    hex: @file("fixtures/sort/sort_1000.hex")
}

fixture matrixData {
    hex: @file("fixtures/matmul/mat_64.hex")
}`
    },
  ]}
/>

<Aside type="tip">
<span>Keep fixture files in a <code>fixtures/</code> subdirectory next to your <code>.bench</code> files. Organize by benchmark type (e.g. <code>fixtures/sort/</code>, <code>fixtures/keccak/</code>) when you have many.</span>
</Aside>

#### Generating fixture files

Fixture files contain raw hex bytes — one long hex string, no newlines. You can generate them with any language:

<CodeGroup
  tabs={[
    {
      title: "Go",
      language: "bash",
      code: `# Generate 1024 random bytes as hex
go run -e 'import "crypto/rand"; import "encoding/hex"; import "os"
func main() {
    b := make([]byte, 1024)
    rand.Read(b)
    os.WriteFile("fixtures/input_1024.hex", []byte(hex.EncodeToString(b)), 0644)
}'`
    },
    {
      title: "Python",
      language: "bash",
      code: `# Generate 1024 random bytes as hex
python3 -c "import os; open('fixtures/input_1024.hex','w').write(os.urandom(1024).hex())"`
    },
    {
      title: "Shell",
      language: "bash",
      code: `# Generate 1024 random bytes as hex (macOS/Linux)
dd if=/dev/urandom bs=1024 count=1 2>/dev/null | xxd -p | tr -d '\n' > fixtures/input_1024.hex`
    },
  ]}
/>

---

### Multiple Fixtures for Scaling Benchmarks

The most common fixture pattern is a series of fixtures with increasing sizes, paired with a `bench` block for each. poly-bench's speedup chart extracts the numeric suffix from benchmark names for the x-axis.

<CodeGroup
  tabs={[
    {
      title: "sort.bench",
      language: "bench",
      code: `use std::charting

suite sortN {
    description: "O(n log n) sort — stdlib sort on int32 array"
    mode: "auto"
    targetTime: 500ms
    compare: true
    baseline: "go"

    setup go {
        import (
            "encoding/binary"
            "sort"
        )

        helpers {
            func sortGo(data []byte) []byte {
                n := len(data) / 4
                arr := make([]int32, n)
                for i := 0; i < n; i++ {
                    arr[i] = int32(binary.BigEndian.Uint32(data[i*4 : (i+1)*4]))
                }
                sort.Slice(arr, func(i, j int) bool { return arr[i] < arr[j] })
                out := make([]byte, len(data))
                for i := 0; i < n; i++ {
                    binary.BigEndian.PutUint32(out[i*4:(i+1)*4], uint32(arr[i]))
                }
                return out
            }
        }
    }

    setup ts {
        helpers {
            function sortTs(data: Uint8Array): Uint8Array {
                const n = data.length / 4
                const arr = []
                for (let i = 0; i < n; i++) {
                    arr.push(data[i*4]<<24 | data[i*4+1]<<16 | data[i*4+2]<<8 | data[i*4+3])
                }
                arr.sort((a, b) => a - b)
                const out = new Uint8Array(data.length)
                for (let i = 0; i < n; i++) {
                    const v = arr[i] >>> 0
                    out[i*4] = (v>>24)&0xff; out[i*4+1] = (v>>16)&0xff
                    out[i*4+2] = (v>>8)&0xff; out[i*4+3] = v&0xff
                }
                return out
            }
        }
    }

    setup rust {
        helpers {
            fn sort_rust(data: &[u8]) -> Vec<u8> {
                let n = data.len() / 4;
                let mut arr: Vec<i32> = (0..n).map(|i| {
                    let j = i * 4;
                    i32::from_be_bytes([data[j], data[j+1], data[j+2], data[j+3]])
                }).collect();
                arr.sort_unstable();
                let mut out = vec![0u8; data.len()];
                for (i, &v) in arr.iter().enumerate() {
                    out[i*4..(i+1)*4].copy_from_slice(&v.to_be_bytes());
                }
                out
            }
        }
    }

    # Ten fixtures — n=100 through n=1000
    fixture s100  { hex: @file("fixtures/sort/sort_100.hex") }
    fixture s200  { hex: @file("fixtures/sort/sort_200.hex") }
    fixture s300  { hex: @file("fixtures/sort/sort_300.hex") }
    fixture s400  { hex: @file("fixtures/sort/sort_400.hex") }
    fixture s500  { hex: @file("fixtures/sort/sort_500.hex") }
    fixture s600  { hex: @file("fixtures/sort/sort_600.hex") }
    fixture s700  { hex: @file("fixtures/sort/sort_700.hex") }
    fixture s800  { hex: @file("fixtures/sort/sort_800.hex") }
    fixture s900  { hex: @file("fixtures/sort/sort_900.hex") }
    fixture s1000 { hex: @file("fixtures/sort/sort_1000.hex") }

    # Benchmark names encode the size — drawSpeedupChart uses this for the x-axis
    bench n100  { go: sortGo(s100)   ts: sortTs(s100)   rust: sort_rust(&s100) }
    bench n200  { go: sortGo(s200)   ts: sortTs(s200)   rust: sort_rust(&s200) }
    bench n300  { go: sortGo(s300)   ts: sortTs(s300)   rust: sort_rust(&s300) }
    bench n400  { go: sortGo(s400)   ts: sortTs(s400)   rust: sort_rust(&s400) }
    bench n500  { go: sortGo(s500)   ts: sortTs(s500)   rust: sort_rust(&s500) }
    bench n600  { go: sortGo(s600)   ts: sortTs(s600)   rust: sort_rust(&s600) }
    bench n700  { go: sortGo(s700)   ts: sortTs(s700)   rust: sort_rust(&s700) }
    bench n800  { go: sortGo(s800)   ts: sortTs(s800)   rust: sort_rust(&s800) }
    bench n900  { go: sortGo(s900)   ts: sortTs(s900)   rust: sort_rust(&s900) }
    bench n1000 { go: sortGo(s1000)  ts: sortTs(s1000)  rust: sort_rust(&s1000) }

    after {
        charting.drawSpeedupChart(
            title: "Sort Performance — O(n log n)",
            output: "sort-line.svg",
            xlabel: "Array Size (n elements)"
        )

        charting.drawTable(
            title: "Sort Comparison",
            output: "sort-bar.svg",
            xlabel: "Array Size"
        )
    }
}`
    },
  ]}
/>

---

### `description` and `shape` Annotations

Both fields are optional and for documentation / tooling purposes only — they have no effect on benchmark execution.

<CodeGroup
  tabs={[
    {
      title: "bench",
      language: "bench",
      code: `fixture keccakInput {
    description: "32-byte input for keccak256 — typical EVM calldata size"
    hex: "68656c6c6f20776f726c6468656c6c6f20776f726c6468656c6c6f20776f72"
}

fixture matrixData {
    description: "64×64 float64 matrix encoded as little-endian bytes"
    hex: @file("fixtures/matmul/mat_64.hex")
    shape: { rows: 64, cols: 64, dtype: "float64", encoding: "little-endian" }
}

fixture sortData {
    description: "1000 random int32 values in big-endian byte order"
    hex: @file("fixtures/sort/sort_1000.hex")
    shape: { count: 1000, dtype: "int32", encoding: "big-endian" }
}`
    },
  ]}
/>

---

### Fixtures Shared Across Multiple Benchmarks

A fixture defined once in a suite is available to every `bench` block in that suite. This is the primary reason to use fixtures over hardcoding values in bench expressions.

<CodeGroup
  tabs={[
    {
      title: "bench",
      language: "bench",
      code: `suite cryptoBench {
    # ... setup ...

    fixture data32  { hex: "68656c6c6f20776f726c6468656c6c6f20776f726c6468656c6c6f20776f72" }
    fixture data256 { hex: @file("fixtures/keccak/input_256.hex") }

    # Both benchmarks use the same fixtures
    bench keccak256_32 {
        go: keccak256Go(data32)
        ts: keccak256Ts(data32)
        rust: keccak256_rust(&data32)
    }

    bench keccak256_256 {
        go: keccak256Go(data256)
        ts: keccak256Ts(data256)
        rust: keccak256_rust(&data256)
    }

    bench sha256_32 {
        go: sha256Go(data32)
        ts: sha256Ts(data32)
        rust: sha256_rust(&data32)
    }

    bench sha256_256 {
        go: sha256Go(data256)
        ts: sha256Ts(data256)
        rust: sha256_rust(&data256)
    }
}`
    },
  ]}
/>

---

### Fixture Naming Conventions

| Pattern | When to use |
|---------|-------------|
| `data`, `input` | Single-fixture benchmarks |
| `small`, `medium`, `large` | Two or three size tiers |
| `s100`, `s500`, `s1000` | Scaling series (prefix + size number) |
| `n100`, `n200`, ..., `n1000` | Scaling series where benchmark names mirror fixture names |
| `mat8`, `mat16`, ..., `mat64` | Matrix benchmarks |
| `r100`, `r200`, ..., `r1000` | Random data series |

<Aside type="tip">
<span>When using <code>drawSpeedupChart</code>, name your <code>bench</code> blocks (not the fixtures) with a numeric suffix — e.g. <code>bench n100</code>, <code>bench n200</code>. poly-bench extracts the number from the benchmark name for the x-axis, not from the fixture name.</span>
</Aside>

---

### Further Reading

- [DSL Reference — Fixtures](/docs/core/dsl-reference#fixture-blocks) — Full fixture syntax reference
- [Charting Guide](/docs/guides/charting) — Using scaling fixtures with `drawSpeedupChart`
- [Examples](/docs/examples) — Real-world fixture usage patterns
