---
title: Setup Blocks
description: Per-language import, declare, init, and helpers
---

Setup blocks define language-specific imports, package-level declarations, one-time initialization, and helper functions. Each supported language has its own setup block, so you can write Go imports in one block and Rust imports in another.

---

## Structure

<CodeGroup 
  tabs={[
    {
      title: "Structure",
      language: "bench",
      code: `setup <lang> {  # [!code focus:5]
    import { ... }
    declare { ... }
    init { ... }
    helpers { ... }
}`
    },
  ]}
/>

All four sub-sections are **optional** and can appear in **any order**. Supported languages: `go`, `ts` (or `typescript`), `rust`, `python`, `c`, `csharp`, `zig`.

<Aside type="note">
<span>All four sub-sections (import, declare, init, helpers) are optional and can appear in any order.</span>
</Aside>

---

## Sub-sections

| Sub-section | Purpose |
|-------------|---------|
| `import` | Language imports (packages, modules, crates) |
| `declare` | Package/module-level variables, constants, types |
| `init` | One-time setup before any benchmarks run |
| `helpers` | Functions available to all `bench` blocks in the suite |

---

## import

The import sub-section declares dependencies used by the setup and helpers. Use it to bring in packages, modules, or crates that your benchmark code needs.

<Aside type="tip">
<span>Use import to bring in packages, modules, or crates your benchmark code needs.</span>
</Aside>

<CodeGroup 
  tabs={[
    {
      title: "Go",
      language: "bench",
      code: `setup go {
    import (  # [!code focus:4]
        "context"
        "crypto/sha256"
        "github.com/ethereum/go-ethereum/ethclient"
    )
    helpers { ... }
}`
    },
    {
      title: "TypeScript",
      language: "bench",
      code: `setup ts {
    import {  # [!code focus:4]
        import { createPublicClient, http } from 'viem'
        import { mainnet } from 'viem/chains'
        import { keccak256 } from 'viem'
    }
    helpers { ... }
}`
    },
    {
      title: "Rust",
      language: "bench",
      code: `setup rust {
    import {  # [!code focus:4]
        use tiny_keccak::{Hasher, Keccak};
        use alloy_primitives::Address;
    }
    helpers { ... }
}`
    },
  ]}
/>

---

## declare

The declare sub-section holds package- or module-level variables, constants, or types. These are shared across all benchmarks in the suite.

If you want to access variables from your helper functions or benchmark code, they must be declared in the declare block. poly-bench uses the declare block to isolate and locate these variables when generating code. Variables defined only inside init or helpers without a corresponding declaration will not be found or properly isolated across the generated benchmark harness.

<Aside type="caution">
<span>Variables used in helpers or benchmarks must be declared in the declare block; poly-bench uses it to isolate variables in generated code.</span>
</Aside>

<CodeGroup 
  tabs={[
    {
      title: "Go",
      language: "bench",
      code: `setup go {
    declare {  # [!code focus:5]
        var client *ethclient.Client
        var ctx context.Context
        var mu sync.Mutex
    }
    init {
        ctx = context.Background()
        client, _ = ethclient.Dial(os.Getenv("ANVIL_RPC_URL"))
    }
    helpers { ... }
}`
    },
    {
      title: "TypeScript",
      language: "bench",
      code: `setup ts {
    declare {  # [!code focus:5]
        let client: any
        const VITALIK = '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'
    }
    init {
        client = createPublicClient({
            chain: mainnet,
            transport: http(ANVIL_RPC_URL),
        })
    }
    helpers { ... }
}`
    },
    {
      title: "Rust",
      language: "bench",
      code: `setup rust {
    declare {  # [!code focus:4]
        static VITALIK: &str = "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045";
    }
    init {
        // One-time initialization
    }
    helpers { ... }
}`
    },
  ]}
/>

---

## init

The init sub-section runs once before any benchmarks in the suite. Use it to connect to services, load config, or initialize shared state that your helpers and benchmarks depend on.

<CodeGroup 
  tabs={[
    {
      title: "Go",
      language: "bench",
      code: `setup go {
    declare { var client *ethclient.Client }
    init {
        client, _ = ethclient.Dial(os.Getenv("ANVIL_RPC_URL"))
    }
    helpers {
        func getBlock() uint64 {
            num, _ := client.BlockNumber(context.Background())
            return num
        }
    }
}`
    },
    {
      title: "TypeScript (async)",
      language: "bench",
      code: `setup ts {
    declare { let client: any }
    async init {  # [!code focus:5]
        client = createPublicClient({
            chain: mainnet,
            transport: http(ANVIL_RPC_URL),
        })
        await client.getBlockNumber()  # Optional: verify connection
    }
    helpers {
        async function getBlock(): Promise<bigint> {
            return await client.getBlockNumber()
        }
    }
}`
    },
    {
      title: "Rust",
      language: "bench",
      code: `setup rust {
    init {
        // One-time setup if needed
    }
    helpers {
        fn keccak256(data: &[u8]) -> [u8; 32] {
            let mut hasher = Keccak::v256();
            let mut output = [0u8; 32];
            hasher.update(data);
            hasher.finalize(&mut output);
            output
        }
    }
}`
    },
  ]}
/>

<Aside type="note">
<span>TypeScript supports <code>async init</code> for asynchronous one-time setup. Use <code>await</code> freely inside it.</span>
</Aside>

---

## helpers

The helpers sub-section defines functions that are available to all bench blocks in the suite. They receive fixture data and other arguments as parameters, and you can call them from your benchmark expressions.

<CodeGroup 
  tabs={[
    {
      title: "Go",
      language: "bench",
      code: `setup go {
    helpers {
        func keccak256(data []byte) [32]byte {
            return sha256.Sum256(data)
        }
        func bubbleSort(data []byte) []byte {
            n := len(data) / 4
            arr := make([]int32, n)
            // ... sort logic ...
            return out
        }
    }
}`
    },
    {
      title: "TypeScript",
      language: "bench",
      code: `setup ts {
    helpers {
        function keccak256(data: Uint8Array): Uint8Array {
            return keccak256(data, 'bytes')
        }
        function bubbleSort(data: Uint8Array): Uint8Array {
            const n = data.length / 4
            const arr = new Array(n)
            // ... sort logic ...
            return out
        }
    }
}`
    },
    {
      title: "Rust",
      language: "bench",
      code: `setup rust {
    helpers {
        fn keccak256(data: &[u8]) -> [u8; 32] {
            let mut hasher = Keccak::v256();
            let mut output = [0u8; 32];
            hasher.update(data);
            hasher.finalize(&mut output);
            output
        }
        fn bubble_sort(data: &[u8]) -> Vec<u8> {
            let n = data.len() / 4;
            let mut arr: Vec<i32> = (0..n).map(|i| ...).collect();
            // ... sort logic ...
            out
        }
    }
}`
    },
  ]}
/>

---

## Complete Example

<CodeGroup 
  tabs={[
    {
      title: "Full setup (Go)",
      language: "bench",
      code: `setup go {
    import (
        "encoding/binary"
    )

    declare {
        var counter int
    }

    init {
        counter = 0
    }

    helpers {
        func bubbleGo(data []byte) []byte {
            n := len(data) / 4
            arr := make([]int32, n)
            for i := 0; i < n; i++ {
                arr[i] = int32(binary.BigEndian.Uint32(data[i*4:(i+1)*4]))
            }
            for i := 0; i < n; i++ {
                for j := 0; j < n-1-i; j++ {
                    if arr[j] > arr[j+1] {
                        arr[j], arr[j+1] = arr[j+1], arr[j]
                    }
                }
            }
            out := make([]byte, len(data))
            for i := 0; i < n; i++ {
                binary.BigEndian.PutUint32(out[i*4:(i+1)*4], uint32(arr[i]))
            }
            return out
        }
    }
}`
    },
  ]}
/>
