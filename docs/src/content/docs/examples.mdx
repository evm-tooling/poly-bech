---
title: Benchmark Features
description: Advanced benchmark features — fixtures, lifecycle hooks, globalSetup, and charting
---

<div data-pagefind-weight="10">

Once you've created your first benchmark with [Getting Started](/docs/getting-started), you can use these features to build more powerful and flexible benchmarks. This page covers fixtures, lifecycle hooks, global setup, and suite-level charting.

</div>

---

## Fixtures

Fixtures define shared test data passed to every language implementation. They ensure all languages operate on identical input.

### Inline hex

Use `hex:` for small, fixed test vectors. The bytes are decoded and passed to each language as its native byte array type.

<CodeGroup 
  tabs={[
    {
      title: "Inline hex",
      language: "bench",
      code: `fixture shortData {
    hex: "68656c6c6f20776f726c64"   # "hello world" in UTF-8  # [!code focus:1]
}

bench hashShort {
    go: keccak256Go(shortData)
    ts: keccak256Ts(shortData)
    rust: keccak256_rust(&shortData)
}`
    },
  ]}
/>

### File-referenced hex

For larger payloads, load hex from an external file. The path is relative to the `.bench` file.

<CodeGroup 
  tabs={[
    {
      title: "@file reference",
      language: "bench",
      code: `fixture largePayload {
    hex: @file("fixtures/sort/sort_1000.hex")  # [!code focus:1]
}

bench sortLarge {
    go: bubbleGo(largePayload)
    ts: bubbleTs(largePayload)
    rust: bubble_rust(&largePayload)
}`
    },
  ]}
/>

<Aside type="tip">
<span>Keep fixture files in a <code>fixtures/</code> subdirectory next to your <code>.bench</code> files. Organize by benchmark type (e.g. <code>fixtures/sort/</code>, <code>fixtures/keccak/</code>).</span>
</Aside>

### Data with encoding

Use `data` for non-hex external samples. `encoding` controls byte decoding.

<CodeGroup 
  tabs={[
    {
      title: "Raw / UTF-8 / Base64",
      language: "bench",
      code: `fixture packetRaw {
    data: @file("fixtures/net/packet.bin")
    encoding: raw
}

fixture payloadUtf8 {
    data: "hello world"
    encoding: utf8
}

fixture payloadB64 {
    data: "aGVsbG8gd29ybGQ="
    encoding: base64
}`
    },
  ]}
/>

See the [Fixtures Guide](/docs/guides/fixtures) for structured extraction (`format` + `selector`), JSON/CSV support, and more.

---

## Lifecycle Hooks (per‑benchmark)

Hooks run at specific points in the benchmark lifecycle. They are defined **per-language** on individual `bench` blocks, not at the suite level.

| Hook | When it runs |
|------|--------------|
| `before <lang>` | Once before the timed loop starts for that language |
| `each <lang>` | Before each iteration, outside the timing window |
| `after <lang>` | Once after the timed loop ends for that language |

Use `before` for setup that should not be included in timing. Use `each` to reset mutable state between iterations. Use `after` for teardown or inspection.

<CodeGroup 
  tabs={[
    {
      title: "Flat syntax",
      language: "bench",
      code: `bench withHooks {
    before go: resetCounter()  # [!code focus:2]
    before ts: resetCounter()

    each go: prepareIteration()
    each ts: prepareIteration()

    go: runBenchmark()
    ts: runBenchmark()

    after go: { _ = counter }
    after ts: { void counter }
}`
    },
    {
      title: "Grouped syntax",
      language: "bench",
      code: `bench withHooks {
    before: {
        go: resetCounter()
        ts: resetCounter()
    }

    each: {
        go: prepareIteration()
        ts: prepareIteration()
    }

    go: runBenchmark()
    ts: runBenchmark()

    after: {
        go: { _ = counter }
        ts: { void counter }
    }
}`
    },
  ]}
/>

<Aside type="tip">
<span>Hook bodies can be either an inline expression (e.g. <code>before go: resetState()</code>) or a multi-line block (e.g. <code>after go: &#123; _ = x &#125;</code>).</span>
</Aside>

---

## globalSetup

The `globalSetup` block runs once before all benchmarks in the file. It is the correct place to spawn long-lived services like an Anvil node for Ethereum RPC benchmarks.

<CodeGroup 
  tabs={[
    {
      title: "File-level",
      language: "bench",
      code: `use std::anvil

globalSetup {
    anvil.spawnAnvil()                           # Local node, no fork
    anvil.spawnAnvil(fork: "https://rpc.url")    # Fork from an RPC endpoint
}

suite evmBench {
    # ... setup, fixtures, benchmarks ...
}`
    },
    {
      title: "Suite-level",
      language: "bench",
      code: `suite evmBench {
    globalSetup {
        anvil.spawnAnvil(fork: "https://eth.llamarpc.com")
    }

    # ... setup, fixtures, benchmarks ...
}`
    },
  ]}
/>

<Aside type="note">
<span>When <code>anvil.spawnAnvil()</code> is called, <code>ANVIL_RPC_URL</code> is injected into TypeScript and available via env var for Go/Rust.</span>
</Aside>

See the [Anvil & EVM Guide](/docs/guides/anvil) for full walkthrough.

---

## Suite-level `after` Block

The suite-level `after` block runs after all benchmarks complete. It is the correct place for chart generation directives. It requires `use std::charting` at the top of the file.

<CodeGroup 
  tabs={[
    {
      title: "Chart generation",
      language: "bench",
      code: `use std::charting

declare suite mySuite performance timeBased sameDataset: true {
    baseline: "go"
    warmup: 100
    targetTime: 1000ms

    setup go { ... }
    setup ts { ... }
    setup rust { ... }

    fixture data { hex: "68656c6c6f" }

    bench hashShort {
        go: hash(data)
        ts: hash(data)
        rust: hash(&data)
    }

    bench hashLong {
        go: hash(largeData)
        ts: hash(largeData)
        rust: hash(&largeData)
    }

    after {
        charting.drawTable(
            title: "Hash Performance",
            output: "hash-table.svg"
        )
        charting.drawSpeedupChart(
            title: "Speedup vs Go",
            output: "hash-speedup.svg"
        )
    }
}`
    },
  ]}
/>

Charts are written to the output directory (e.g. `out/` when using `poly-bench run --output out/`).

See the [Charting Guide](/docs/guides/charting) for all chart types and parameters.

---

## Next Steps

- [Features](/docs/features) — Per-feature reference (suites, setup, benchmarks, fixtures, globalSetup)
- [Charting Guide](/docs/guides/charting) — Every chart type with real examples
- [Anvil & EVM Guide](/docs/guides/anvil) — Benchmarking Ethereum client libraries
- [Fixtures Guide](/docs/guides/fixtures) — Inline hex, file references, structured extraction
- [CLI Recipes](/docs/guides/cli-recipes) — Practical workflows and CI integration
- [DSL Reference](/docs/core/dsl-reference) — Complete syntax documentation
- [Standard Library](/docs/core/standard-library) — `std::anvil`, `std::charting`, `std::constants`
