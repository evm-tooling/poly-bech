//! Go plugin source code generation

use poly_bench_dsl::{Lang, BenchMode};
use poly_bench_ir::{BenchmarkIR, SuiteIR, BenchmarkSpec, FixtureIR};
use poly_bench_stdlib as stdlib;
use miette::{Result, miette};

/// Generate Go plugin source code from IR
pub fn generate(ir: &BenchmarkIR) -> Result<String> {
    let mut code = String::new();

    // Package declaration
    code.push_str("// Code generated by poly-bench. DO NOT EDIT.\n\npackage main\n\n");
    
    // Collect all user imports from all suites
    let mut user_imports: Vec<&str> = Vec::new();
    for suite in &ir.suites {
        if let Some(imports) = suite.imports.get(&Lang::Go) {
            for import_spec in imports {
                user_imports.push(import_spec);
            }
        }
    }
    
    // Collect stdlib imports
    let stdlib_imports = stdlib::get_stdlib_imports(&ir.stdlib_imports, Lang::Go);
    
    // Check if any benchmark uses sink pattern
    let needs_runtime = ir.suites.iter().any(|suite| {
        suite.benchmarks.iter().any(|bench| bench.use_sink && bench.has_lang(Lang::Go))
    });

    // Generate unified import block with deduplication
    let mut all_imports: std::collections::HashSet<&str> = std::collections::HashSet::new();
    all_imports.insert("\"encoding/json\"");
    all_imports.insert("\"time\"");
    if needs_runtime {
        all_imports.insert("\"runtime\"");
    }
    for import_spec in &user_imports {
        all_imports.insert(import_spec);
    }
    for import_spec in &stdlib_imports {
        all_imports.insert(import_spec);
    }
    
    code.push_str("import (\n");
    let mut sorted_imports: Vec<_> = all_imports.into_iter().collect();
    sorted_imports.sort();
    for import_spec in sorted_imports {
        code.push_str(&format!("\t{}\n", import_spec));
    }
    code.push_str(")\n\n");

    // Inject stdlib code if any modules are imported
    let stdlib_code = stdlib::get_stdlib_code(&ir.stdlib_imports, Lang::Go);
    if !stdlib_code.is_empty() {
        code.push_str(&stdlib_code);
        code.push_str("\n");
    }

    // BenchResult type
    code.push_str(r#"// BenchResult holds the benchmark measurement results
type BenchResult struct {
	Iterations  uint64   `json:"iterations"`
	TotalNanos  uint64   `json:"total_nanos"`
	NanosPerOp  float64  `json:"nanos_per_op"`
	OpsPerSec   float64  `json:"ops_per_sec"`
	BytesPerOp  uint64   `json:"bytes_per_op"`
	AllocsPerOp uint64   `json:"allocs_per_op"`
	Samples     []uint64 `json:"samples,omitempty"`
}

// Export symbols for plugin loading
var (
	RunBenchmark  = runBenchmark
	ListBenchmarks = listBenchmarks
)

"#);

    // Generate code for each suite
    for suite in &ir.suites {
        generate_suite(&mut code, suite)?;
    }

    // Generate the main runner function
    code.push_str(r#"
// runBenchmark executes a benchmark by name and returns JSON results
func runBenchmark(name string, iterations int) string {
	var result BenchResult

	switch name {
"#);

    for suite in &ir.suites {
        for bench in &suite.benchmarks {
            if bench.has_lang(Lang::Go) {
                code.push_str(&format!(
                    "\tcase \"{}\":\n\t\tresult = bench_{}(iterations)\n",
                    bench.full_name, bench.full_name
                ));
            }
        }
    }

    code.push_str(r#"	default:
		result = BenchResult{}
	}

	jsonBytes, _ := json.Marshal(result)
	return string(jsonBytes)
}

// listBenchmarks returns a JSON array of available benchmark names
func listBenchmarks() string {
	names := []string{
"#);

    for suite in &ir.suites {
        for bench in &suite.benchmarks {
            if bench.has_lang(Lang::Go) {
                code.push_str(&format!("\t\t\"{}\",\n", bench.full_name));
            }
        }
    }

    code.push_str(r#"	}
	jsonBytes, _ := json.Marshal(names)
	return string(jsonBytes)
}

func main() {}
"#);

    Ok(code)
}

/// Generate code for a single suite
fn generate_suite(code: &mut String, suite: &SuiteIR) -> Result<()> {
    // Add declarations
    if let Some(declarations) = suite.declarations.get(&Lang::Go) {
        if !declarations.trim().is_empty() {
            code.push_str("// Declarations\n");
            code.push_str(declarations);
            code.push_str("\n\n");
        }
    }

    // Add init function if present
    if let Some(init_code) = suite.init_code.get(&Lang::Go) {
        if !init_code.trim().is_empty() {
            code.push_str("func init() {\n");
            code.push_str(init_code);
            code.push_str("\n}\n\n");
        }
    }

    // Add helpers
    if let Some(helpers) = suite.helpers.get(&Lang::Go) {
        if !helpers.trim().is_empty() {
            code.push_str("// Helpers\n");
            code.push_str(helpers);
            code.push_str("\n\n");
        }
    }

    // Generate fixtures
    for fixture in &suite.fixtures {
        generate_fixture(code, fixture)?;
    }

    // Generate benchmark functions
    for bench in &suite.benchmarks {
        if bench.has_lang(Lang::Go) {
            generate_benchmark(code, bench, suite)?;
        }
    }

    Ok(())
}

/// Generate a fixture variable
fn generate_fixture(code: &mut String, fixture: &FixtureIR) -> Result<()> {
    // Check if there's a Go-specific implementation
    if let Some(impl_code) = fixture.implementations.get(&Lang::Go) {
        code.push_str(&format!("// Fixture: {}\n", fixture.name));
        if let Some(ref desc) = fixture.description {
            code.push_str(&format!("// {}\n", desc));
        }
        code.push_str(&format!("var {} = {}\n\n", fixture.name, impl_code));
    } else if !fixture.data.is_empty() {
        // Use hex data as byte slice
        code.push_str(&format!("// Fixture: {}\n", fixture.name));
        if let Some(ref desc) = fixture.description {
            code.push_str(&format!("// {}\n", desc));
        }
        code.push_str(&format!("var {} = {}\n\n", fixture.name, fixture.as_go_bytes()));
    }

    Ok(())
}

/// Generate a benchmark function
fn generate_benchmark(code: &mut String, bench: &BenchmarkSpec, _suite: &SuiteIR) -> Result<()> {
    let impl_code = bench.get_impl(Lang::Go)
        .ok_or_else(|| miette!("No Go implementation for benchmark {}", bench.name))?;

    code.push_str(&format!("// Benchmark: {}\n", bench.name));
    if let Some(ref desc) = bench.description {
        code.push_str(&format!("// {}\n", desc));
    }

    // Generate sink variable and benchmark call based on use_sink setting
    let sink_decl = if bench.use_sink { "\tvar __sink interface{}\n" } else { "" };
    let bench_call = if bench.use_sink {
        format!("__sink = {}", impl_code)
    } else {
        format!("_ = {}", impl_code)
    };
    let sink_keepalive = if bench.use_sink {
        "\t\truntime.KeepAlive(__sink)\n"
    } else {
        ""
    };

    match bench.mode {
        BenchMode::Auto => {
            // Auto-calibration mode
            code.push_str(&format!(r#"func bench_{}(iterations int) BenchResult {{
	// Auto-calibration mode: iterations parameter is a hint, actual count may vary
	targetNanos := int64({})
	minIters := {}
	maxIters := {}
{}
	// Calibration phase
	iters := 1
	for iters < maxIters {{
		start := time.Now()
		for i := 0; i < iters; i++ {{
			{}
{}		}}
		elapsed := time.Since(start).Nanoseconds()
		if elapsed >= targetNanos {{
			break
		}}
		if elapsed > 0 {{
			newIters := int(float64(iters) * float64(targetNanos) / float64(elapsed) * 1.2)
			if newIters <= iters {{
				newIters = iters * 2
			}}
			iters = newIters
		}} else {{
			iters *= 10
		}}
		if iters > maxIters {{
			iters = maxIters
		}}
	}}
	if iters < minIters {{
		iters = minIters
	}}
	
	// Warmup (10% of calibrated iterations)
	warmup := iters / 10
	if warmup < 10 {{
		warmup = 10
	}}
	for i := 0; i < warmup; i++ {{
		{}
{}	}}
	
	// Timed run
	samples := make([]uint64, iters)
	var totalNanos uint64
	for i := 0; i < iters; i++ {{
		start := time.Now()
		{}
{}		elapsed := time.Since(start).Nanoseconds()
		samples[i] = uint64(elapsed)
		totalNanos += uint64(elapsed)
	}}
	
	nanosPerOp := float64(totalNanos) / float64(iters)
	opsPerSec := 1e9 / nanosPerOp
	
	return BenchResult{{
		Iterations:  uint64(iters),
		TotalNanos:  totalNanos,
		NanosPerOp:  nanosPerOp,
		OpsPerSec:   opsPerSec,
		Samples:     samples,
	}}
}}

"#, bench.full_name, bench.target_time_ms * 1_000_000, bench.min_iterations, bench.max_iterations, 
    sink_decl, bench_call, sink_keepalive, bench_call, sink_keepalive, bench_call, sink_keepalive));
        }
        BenchMode::Fixed => {
            // Fixed iteration mode (original behavior with sink pattern)
            code.push_str(&format!(r#"func bench_{}(iterations int) BenchResult {{
	samples := make([]uint64, iterations)
{}
	// Warmup
	for i := 0; i < {}; i++ {{
		{}
{}	}}
	
	// Timed run
	var totalNanos uint64
	for i := 0; i < iterations; i++ {{
		start := time.Now()
		{}
{}		elapsed := time.Since(start).Nanoseconds()
		samples[i] = uint64(elapsed)
		totalNanos += uint64(elapsed)
	}}
	
	nanosPerOp := float64(totalNanos) / float64(iterations)
	opsPerSec := 1e9 / nanosPerOp
	
	return BenchResult{{
		Iterations:  uint64(iterations),
		TotalNanos:  totalNanos,
		NanosPerOp:  nanosPerOp,
		OpsPerSec:   opsPerSec,
		Samples:     samples,
	}}
}}

"#, bench.full_name, sink_decl, bench.warmup, bench_call, sink_keepalive, bench_call, sink_keepalive));
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use poly_bench_dsl::parse;
    use poly_bench_ir::lower;

    #[test]
    fn test_generate_simple() {
        let source = r#"
suite hash {
    iterations: 1000
    warmup: 10
    
    fixture data {
        hex: "deadbeef"
    }
    
    bench keccak256 {
        go: keccak256(data)
    }
}
"#;
        let ast = parse(source, "test.bench").unwrap();
        let ir = lower(&ast, None).unwrap();
        let code = generate(&ir).unwrap();
        
        assert!(code.contains("package main"));
        assert!(code.contains("func bench_hash_keccak256"));
        assert!(code.contains("var data = []byte{0xde, 0xad, 0xbe, 0xef}"));
    }

    #[test]
    fn test_generate_with_stdlib_constants() {
        let source = r#"
use std::constants

suite math {
    iterations: 100
    
    bench pi_calc {
        go: compute(std_PI)
    }
}
"#;
        let ast = parse(source, "test.bench").unwrap();
        let ir = lower(&ast, None).unwrap();
        let code = generate(&ir).unwrap();
        
        // Verify stdlib constants are injected
        assert!(code.contains("std_PI"));
        assert!(code.contains("std_E"));
        assert!(code.contains("float64"));
        assert!(code.contains("3.14159"));
    }

    #[test]
    fn test_generate_without_stdlib() {
        let source = r#"
suite test {
    iterations: 100
    
    fixture data {
        hex: "deadbeef"
    }
    
    bench simple {
        go: test(data)
    }
}
"#;
        let ast = parse(source, "test.bench").unwrap();
        let ir = lower(&ast, None).unwrap();
        let code = generate(&ir).unwrap();
        
        // Should not contain stdlib constants
        assert!(!code.contains("std_PI"));
        assert!(!code.contains("std_E"));
    }
}
