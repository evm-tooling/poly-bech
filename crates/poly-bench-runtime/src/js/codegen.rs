//! TypeScript/JavaScript code generation

use poly_bench_dsl::Lang;
use poly_bench_ir::{BenchmarkIR, SuiteIR, BenchmarkSpec, FixtureIR};
use poly_bench_stdlib as stdlib;
use miette::{Result, miette};

/// Generate TypeScript benchmark code from IR
pub fn generate(ir: &BenchmarkIR) -> Result<String> {
    let mut code = String::new();

    code.push_str("// Code generated by poly-bench. DO NOT EDIT.\n\n");
    
    // Collect all user imports from all suites (must be at top of file for ES modules)
    let mut has_imports = false;
    for suite in &ir.suites {
        if let Some(imports) = suite.imports.get(&Lang::TypeScript) {
            for import_stmt in imports {
                code.push_str(import_stmt);
                code.push('\n');
                has_imports = true;
            }
        }
    }
    if has_imports {
        code.push('\n');
    }

    // Inject stdlib code if any modules are imported
    let stdlib_code = stdlib::get_stdlib_code(&ir.stdlib_imports, Lang::TypeScript);
    if !stdlib_code.is_empty() {
        code.push_str(&stdlib_code);
        code.push_str("\n");
    }

    code.push_str(r#"/**
 * Benchmark harness for poly-bench TypeScript execution
 */

interface BenchResult {
    iterations: number;
    totalNanos: number;
    nanosPerOp: number;
    opsPerSec: number;
    samples: number[];
}

// Performance timing helper
const now = typeof performance !== 'undefined' 
    ? () => performance.now() * 1e6  // Convert ms to ns
    : () => Date.now() * 1e6;

function runBenchmark(fn: () => void, iterations: number, warmup: number): BenchResult {
    const samples: number[] = [];
    
    // Warmup
    for (let i = 0; i < warmup; i++) {
        fn();
    }
    
    // Timed run
    let totalNanos = 0;
    for (let i = 0; i < iterations; i++) {
        const start = now();
        fn();
        const elapsed = now() - start;
        samples.push(elapsed);
        totalNanos += elapsed;
    }
    
    const nanosPerOp = totalNanos / iterations;
    const opsPerSec = 1e9 / nanosPerOp;
    
    return {
        iterations,
        totalNanos,
        nanosPerOp,
        opsPerSec,
        samples,
    };
}

"#);

    // Generate code for each suite
    for suite in &ir.suites {
        generate_suite(&mut code, suite)?;
    }

    // Generate benchmark registry
    code.push_str("// Benchmark registry\n");
    code.push_str("const benchmarks: Map<string, () => BenchResult> = new Map([\n");

    for suite in &ir.suites {
        for bench in &suite.benchmarks {
            if bench.has_lang(Lang::TypeScript) {
                code.push_str(&format!(
                    "    [\"{}\", () => bench_{}({}, {})],\n",
                    bench.full_name, bench.full_name, bench.iterations, bench.warmup
                ));
            }
        }
    }

    code.push_str("]);\n\n");

    // Generate runner functions
    code.push_str(r#"
// Run a benchmark by name
function runBenchmarkByName(name: string): string {
    const benchFn = benchmarks.get(name);
    if (!benchFn) {
        return JSON.stringify({ error: `Unknown benchmark: ${name}` });
    }
    return JSON.stringify(benchFn());
}

// List all available benchmarks
function listBenchmarks(): string {
    return JSON.stringify(Array.from(benchmarks.keys()));
}

// Export for poly-bench runtime
export { runBenchmarkByName, listBenchmarks, benchmarks };
"#);

    Ok(code)
}

/// Generate code for a single suite
fn generate_suite(code: &mut String, suite: &SuiteIR) -> Result<()> {
    code.push_str(&format!("// Suite: {}\n", suite.name));
    if let Some(ref desc) = suite.description {
        code.push_str(&format!("// {}\n", desc));
    }
    code.push_str("\n");

    // Add declarations
    if let Some(declarations) = suite.declarations.get(&Lang::TypeScript) {
        if !declarations.trim().is_empty() {
            code.push_str("// Declarations\n");
            code.push_str(declarations);
            code.push_str("\n\n");
        }
    }

    // Add init code (wrapped in IIFE)
    if let Some(init_code) = suite.init_code.get(&Lang::TypeScript) {
        if !init_code.trim().is_empty() {
            let is_async = suite.has_async_init(Lang::TypeScript);
            if is_async {
                code.push_str("// Async init\n");
                code.push_str("await (async () => {\n");
                code.push_str(init_code);
                code.push_str("\n})();\n\n");
            } else {
                code.push_str("// Init\n");
                code.push_str("(() => {\n");
                code.push_str(init_code);
                code.push_str("\n})();\n\n");
            }
        }
    }

    // Add helpers
    if let Some(helpers) = suite.helpers.get(&Lang::TypeScript) {
        if !helpers.trim().is_empty() {
            code.push_str("// Helpers\n");
            code.push_str(helpers);
            code.push_str("\n\n");
        }
    }

    // Generate fixtures
    for fixture in &suite.fixtures {
        generate_fixture(code, fixture)?;
    }

    // Generate benchmark functions
    for bench in &suite.benchmarks {
        if bench.has_lang(Lang::TypeScript) {
            generate_benchmark(code, bench)?;
        }
    }

    Ok(())
}

/// Generate a fixture constant
fn generate_fixture(code: &mut String, fixture: &FixtureIR) -> Result<()> {
    code.push_str(&format!("// Fixture: {}\n", fixture.name));
    if let Some(ref desc) = fixture.description {
        code.push_str(&format!("// {}\n", desc));
    }

    // Check if there's a TS-specific implementation
    if let Some(impl_code) = fixture.implementations.get(&Lang::TypeScript) {
        code.push_str(&format!("const {} = {};\n\n", fixture.name, impl_code));
    } else if !fixture.data.is_empty() {
        // Use hex data - provide as both Uint8Array and hex string
        code.push_str(&format!(
            "const {} = {};\n",
            fixture.name,
            fixture.as_js_uint8array()
        ));
        code.push_str(&format!(
            "const {}_hex = \"{}\";\n\n",
            fixture.name,
            fixture.as_hex_prefixed()
        ));
    }

    Ok(())
}

/// Generate a benchmark function
fn generate_benchmark(code: &mut String, bench: &BenchmarkSpec) -> Result<()> {
    let impl_code = bench.get_impl(Lang::TypeScript)
        .ok_or_else(|| miette!("No TypeScript implementation for benchmark {}", bench.name))?;

    code.push_str(&format!("// Benchmark: {}\n", bench.name));
    if let Some(ref desc) = bench.description {
        code.push_str(&format!("// {}\n", desc));
    }

    code.push_str(&format!(r#"function bench_{}(iterations: number, warmup: number): BenchResult {{
    return runBenchmark(() => {{
        {}
    }}, iterations, warmup);
}}

"#, bench.full_name, impl_code));

    Ok(())
}

/// Generate a standalone benchmark script for subprocess execution
pub fn generate_standalone(ir: &BenchmarkIR, bench_name: &str) -> Result<String> {
    let mut code = generate(ir)?;

    // Add execution code
    code.push_str(&format!(r#"
// Run the specified benchmark and output JSON
const result = runBenchmarkByName("{}");
console.log(result);
"#, bench_name));

    Ok(code)
}

#[cfg(test)]
mod tests {
    use super::*;
    use poly_bench_dsl::parse;
    use poly_bench_ir::lower;

    #[test]
    fn test_generate_simple() {
        let source = r#"
suite hash {
    iterations: 1000
    warmup: 10
    
    fixture data {
        hex: "deadbeef"
    }
    
    bench keccak256 {
        ts: keccak256(data_hex)
    }
}
"#;
        let ast = parse(source, "test.bench").unwrap();
        let ir = lower(&ast, None).unwrap();
        let code = generate(&ir).unwrap();
        
        assert!(code.contains("interface BenchResult"));
        assert!(code.contains("function bench_hash_keccak256"));
        assert!(code.contains("const data = new Uint8Array"));
        assert!(code.contains("const data_hex = \"0xdeadbeef\""));
    }

    #[test]
    fn test_generate_with_stdlib_constants() {
        let source = r#"
use std::constants

suite math {
    iterations: 100
    
    bench pi_calc {
        ts: compute(std_PI)
    }
}
"#;
        let ast = parse(source, "test.bench").unwrap();
        let ir = lower(&ast, None).unwrap();
        let code = generate(&ir).unwrap();
        
        // Verify stdlib constants are injected
        assert!(code.contains("std_PI"));
        assert!(code.contains("std_E"));
        assert!(code.contains("number"));
        assert!(code.contains("3.14159"));
    }

    #[test]
    fn test_generate_without_stdlib() {
        let source = r#"
suite test {
    iterations: 100
    
    fixture data {
        hex: "deadbeef"
    }
    
    bench simple {
        ts: test(data)
    }
}
"#;
        let ast = parse(source, "test.bench").unwrap();
        let ir = lower(&ast, None).unwrap();
        let code = generate(&ir).unwrap();
        
        // Should not contain stdlib constants
        assert!(!code.contains("std_PI"));
        assert!(!code.contains("std_E"));
    }
}
