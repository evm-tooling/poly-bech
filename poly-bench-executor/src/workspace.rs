//! Persistent workspace management for compile checks
//!
//! This module manages the `.polybench/` directory structure used for
//! incremental compilation and caching.

use miette::{miette, Result};
use std::{
    fs,
    path::{Path, PathBuf},
};

/// Directory names within .polybench/
pub const POLYBENCH_DIR: &str = ".polybench";
pub const CACHE_DIR: &str = "cache";
pub const RUST_DIR: &str = "rust";
pub const GO_DIR: &str = "go";
pub const TS_DIR: &str = "ts";

/// Manages the persistent .polybench/ workspace directory
#[derive(Debug, Clone)]
pub struct CompileWorkspace {
    /// Root of the .polybench/ directory
    root: PathBuf,
}

impl CompileWorkspace {
    /// Create a new workspace rooted at the given project directory
    pub fn new(project_root: &Path) -> Result<Self> {
        let root = project_root.join(POLYBENCH_DIR);
        let workspace = Self { root };
        workspace.ensure_structure()?;
        Ok(workspace)
    }

    /// Get the root .polybench/ directory path
    pub fn root(&self) -> &Path {
        &self.root
    }

    /// Get the cache directory path
    pub fn cache_dir(&self) -> PathBuf {
        self.root.join(CACHE_DIR)
    }

    /// Get the Rust workspace directory path
    pub fn rust_dir(&self) -> PathBuf {
        self.root.join(RUST_DIR)
    }

    /// Get the Go workspace directory path
    pub fn go_dir(&self) -> PathBuf {
        self.root.join(GO_DIR)
    }

    /// Get the TypeScript workspace directory path
    pub fn ts_dir(&self) -> PathBuf {
        self.root.join(TS_DIR)
    }

    /// Ensure all required directories exist
    fn ensure_structure(&self) -> Result<()> {
        let dirs =
            [self.root.clone(), self.cache_dir(), self.rust_dir(), self.go_dir(), self.ts_dir()];

        for dir in &dirs {
            if !dir.exists() {
                fs::create_dir_all(dir)
                    .map_err(|e| miette!("Failed to create directory {:?}: {}", dir, e))?;
            }
        }

        // Create .gitignore if it doesn't exist
        let gitignore_path = self.root.join(".gitignore");
        if !gitignore_path.exists() {
            fs::write(&gitignore_path, "# Generated by poly-bench\n*\n!.gitignore\n")
                .map_err(|e| miette!("Failed to create .gitignore: {}", e))?;
        }

        Ok(())
    }

    /// Initialize Rust workspace with Cargo.toml if needed
    pub fn init_rust_workspace(&self, dependencies: &[(&str, &str)]) -> Result<PathBuf> {
        let rust_dir = self.rust_dir();
        let cargo_toml = rust_dir.join("Cargo.toml");
        let src_dir = rust_dir.join("src");

        // Create src directory
        if !src_dir.exists() {
            fs::create_dir_all(&src_dir)
                .map_err(|e| miette!("Failed to create src directory: {}", e))?;
        }

        // Create a minimal lib.rs to make cargo happy
        let lib_rs = src_dir.join("lib.rs");
        if !lib_rs.exists() {
            fs::write(&lib_rs, "// Placeholder for poly-bench compile checks\n")
                .map_err(|e| miette!("Failed to create lib.rs: {}", e))?;
        }

        // Generate Cargo.toml with dependencies
        let mut cargo_content = String::from(
            r#"[package]
name = "polybench-check"
version = "0.0.0"
edition = "2021"
publish = false

[lib]
path = "src/lib.rs"

[[bin]]
name = "check"
path = "src/main.rs"
required-features = []

[dependencies]
"#,
        );

        for (name, version) in dependencies {
            cargo_content.push_str(&format!("{} = \"{}\"\n", name, version));
        }

        // Only write if content changed
        let should_write = if cargo_toml.exists() {
            let existing = fs::read_to_string(&cargo_toml).unwrap_or_default();
            existing != cargo_content
        } else {
            true
        };

        if should_write {
            fs::write(&cargo_toml, &cargo_content)
                .map_err(|e| miette!("Failed to write Cargo.toml: {}", e))?;
        }

        Ok(rust_dir)
    }

    /// Initialize Go module if needed
    pub fn init_go_module(&self, module_name: &str) -> Result<PathBuf> {
        let go_dir = self.go_dir();
        let go_mod = go_dir.join("go.mod");

        if !go_mod.exists() {
            let content = format!("module {}\n\ngo 1.21\n", module_name);
            fs::write(&go_mod, content).map_err(|e| miette!("Failed to write go.mod: {}", e))?;
        }

        Ok(go_dir)
    }

    /// Initialize TypeScript config if needed
    pub fn init_ts_config(&self) -> Result<PathBuf> {
        let ts_dir = self.ts_dir();
        let tsconfig = ts_dir.join("tsconfig.json");

        if !tsconfig.exists() {
            let content = r#"{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": false,
    "skipLibCheck": true,
    "noEmit": true
  },
  "include": ["*.ts"]
}
"#;
            fs::write(&tsconfig, content)
                .map_err(|e| miette!("Failed to write tsconfig.json: {}", e))?;
        }

        Ok(ts_dir)
    }

    /// Clean all generated files but preserve the directory structure
    pub fn clean(&self) -> Result<()> {
        // Clean Rust target directory
        let rust_target = self.rust_dir().join("target");
        if rust_target.exists() {
            fs::remove_dir_all(&rust_target)
                .map_err(|e| miette!("Failed to clean Rust target: {}", e))?;
        }

        // Clean Go build cache files
        for entry in fs::read_dir(self.go_dir()).into_iter().flatten() {
            if let Ok(entry) = entry {
                let path = entry.path();
                if path.extension().map_or(false, |ext| ext == "go") {
                    let _ = fs::remove_file(&path);
                }
            }
        }

        // Clean TypeScript files
        for entry in fs::read_dir(self.ts_dir()).into_iter().flatten() {
            if let Ok(entry) = entry {
                let path = entry.path();
                if path.extension().map_or(false, |ext| ext == "ts" || ext == "js") {
                    let _ = fs::remove_file(&path);
                }
            }
        }

        // Clean cache
        let cache_file = self.cache_dir().join("compile-cache.json");
        if cache_file.exists() {
            let _ = fs::remove_file(&cache_file);
        }

        Ok(())
    }

    /// Get the size of the workspace in bytes
    pub fn size(&self) -> u64 {
        dir_size(&self.root)
    }
}

/// Calculate the total size of a directory recursively
fn dir_size(path: &Path) -> u64 {
    let mut size = 0;
    if let Ok(entries) = fs::read_dir(path) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_dir() {
                size += dir_size(&path);
            } else if let Ok(metadata) = fs::metadata(&path) {
                size += metadata.len();
            }
        }
    }
    size
}

/// Format bytes as human-readable string
pub fn format_size(bytes: u64) -> String {
    const KB: u64 = 1024;
    const MB: u64 = KB * 1024;
    const GB: u64 = MB * 1024;

    if bytes >= GB {
        format!("{:.1} GB", bytes as f64 / GB as f64)
    } else if bytes >= MB {
        format!("{:.1} MB", bytes as f64 / MB as f64)
    } else if bytes >= KB {
        format!("{:.1} KB", bytes as f64 / KB as f64)
    } else {
        format!("{} bytes", bytes)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_workspace_creation() {
        let temp = TempDir::new().unwrap();
        let workspace = CompileWorkspace::new(temp.path()).unwrap();

        assert!(workspace.root().exists());
        assert!(workspace.cache_dir().exists());
        assert!(workspace.rust_dir().exists());
        assert!(workspace.go_dir().exists());
        assert!(workspace.ts_dir().exists());
    }

    #[test]
    fn test_format_size() {
        assert_eq!(format_size(500), "500 bytes");
        assert_eq!(format_size(1500), "1.5 KB");
        assert_eq!(format_size(1_500_000), "1.4 MB");
        assert_eq!(format_size(1_500_000_000), "1.4 GB");
    }
}
