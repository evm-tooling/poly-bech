use std::charting

declare suite bubbleN performance timeBased sameDataset: true {
    description: "O(n^2) bubble sort on int32 array"
    baseline: "go"
    warmup: 100
    targetTime: 100ms
    fairness: "strict"
    cvThreshold: 5
    count: 1

    setup go {
        import (
            "encoding/binary"
        )

        helpers {
            func bubbleGo(data []byte) []byte {
                n := len(data) / 4
                arr := make([]int32, n)
                for i := 0; i < n; i++ {
                    arr[i] = int32(binary.BigEndian.Uint32(data[i*4 : (i+1)*4]))
                }
                for i := 0; i < n; i++ {
                    for j := 0; j < n-1-i; j++ {
                        if arr[j] > arr[j+1] {
                            tmp := arr[j]
                            arr[j] = arr[j+1]
                            arr[j+1] = tmp
                        }
                    }
                }
                out := make([]byte, len(data))
                for i := 0; i < n; i++ {
                    binary.BigEndian.PutUint32(out[i*4:(i+1)*4], uint32(arr[i]))
                }
                return out
            }
        }
    }

    setup ts {
        helpers {
            function bubbleTs(data: Uint8Array): Uint8Array {
                const n = data.length / 4
                const arr = new Array(n)
                for (let i = 0; i < n; i++) {
                    arr[i] = (data[i*4]<<24) | (data[i*4+1]<<16) | (data[i*4+2]<<8) | data[i*4+3]
                }
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n - 1 - i; j++) {
                        if (arr[j] > arr[j+1]) {
                            const tmp = arr[j]
                            arr[j] = arr[j+1]
                            arr[j+1] = tmp
                        }
                    }
                }
                const out = new Uint8Array(data.length)
                const view = new DataView(out.buffer)
                for (let i = 0; i < n; i++) {
                    view.setInt32(i * 4, arr[i], false)
                }
                return out
            }
        }
    }

    setup c {
        helpers {
            static int32_t read_i32_be(const unsigned char* p) {
                return (int32_t)(
                    ((uint32_t)p[0] << 24) |
                    ((uint32_t)p[1] << 16) |
                    ((uint32_t)p[2] << 8) |
                    (uint32_t)p[3]
                );
            }

            static void write_i32_be(unsigned char* p, int32_t v) {
                uint32_t u = (uint32_t)v;
                p[0] = (unsigned char)((u >> 24) & 0xFF);
                p[1] = (unsigned char)((u >> 16) & 0xFF);
                p[2] = (unsigned char)((u >> 8) & 0xFF);
                p[3] = (unsigned char)(u & 0xFF);
            }

            static void bubble_c(unsigned char* data, size_t len) {
                size_t n = len / 4;
                int32_t* arr = (int32_t*)malloc(n * sizeof(int32_t));
                if (!arr) return;
                for (size_t i = 0; i < n; i++) {
                    arr[i] = read_i32_be(data + i * 4);
                }
                for (size_t i = 0; i < n; i++) {
                    for (size_t j = 0; j < n - 1 - i; j++) {
                        if (arr[j] > arr[j + 1]) {
                            int32_t tmp = arr[j];
                            arr[j] = arr[j + 1];
                            arr[j + 1] = tmp;
                        }
                    }
                }
                unsigned char* out = (unsigned char*)malloc(len);
                if (!out) { free(arr); return; }
                for (size_t i = 0; i < n; i++) {
                    write_i32_be(out + i * 4, arr[i]);
                }
                memcpy(data, out, len);
                free(arr);
                free(out);
            }
        }
    }

    fixture s100 {
        hex: @file("fixtures/sort/sort_100.hex")
    }

    fixture s200 {
        hex: @file("fixtures/sort/sort_200.hex")
    }

    fixture s300 {
        hex: @file("fixtures/sort/sort_300.hex")
    }

    fixture s400 {
        hex: @file("fixtures/sort/sort_400.hex")
    }

    fixture s500 {
        hex: @file("fixtures/sort/sort_500.hex")
    }

    fixture s600 {
        hex: @file("fixtures/sort/sort_600.hex")
    }

    fixture s700 {
        hex: @file("fixtures/sort/sort_700.hex")
    }

    fixture s800 {
        hex: @file("fixtures/sort/sort_800.hex")
    }

    fixture s900 {
        hex: @file("fixtures/sort/sort_900.hex")
    }

    fixture s1000 {
        hex: @file("fixtures/sort/sort_1000.hex")
    }

    bench n100 {
        go: bubbleGo(s100)
        ts: bubbleTs(s100)
        c: {
            unsigned char __buf[sizeof(s100)];
            memcpy(__buf, s100, sizeof(__buf));
            bubble_c(__buf, sizeof(__buf));
        }
    }

    bench n200 {
        go: bubbleGo(s200)
        ts: bubbleTs(s200)
        c: {
            unsigned char __buf[sizeof(s200)];
            memcpy(__buf, s200, sizeof(__buf));
            bubble_c(__buf, sizeof(__buf));
        }
    }

    bench n300 {
        go: bubbleGo(s300)
        ts: bubbleTs(s300)
        c: {
            unsigned char __buf[sizeof(s300)];
            memcpy(__buf, s300, sizeof(__buf));
            bubble_c(__buf, sizeof(__buf));
        }
    }

    bench n400 {
        go: bubbleGo(s400)
        ts: bubbleTs(s400)
        c: {
            unsigned char __buf[sizeof(s400)];
            memcpy(__buf, s400, sizeof(__buf));
            bubble_c(__buf, sizeof(__buf));
        }
    }

    bench n500 {
        go: bubbleGo(s500)
        ts: bubbleTs(s500)
        c: {
            unsigned char __buf[sizeof(s500)];
            memcpy(__buf, s500, sizeof(__buf));
            bubble_c(__buf, sizeof(__buf));
        }
    }

    bench n600 {
        go: bubbleGo(s600)
        ts: bubbleTs(s600)
        c: {
            unsigned char __buf[sizeof(s600)];
            memcpy(__buf, s600, sizeof(__buf));
            bubble_c(__buf, sizeof(__buf));
        }
    }

    bench n700 {
        go: bubbleGo(s700)
        ts: bubbleTs(s700)
        c: {
            unsigned char __buf[sizeof(s700)];
            memcpy(__buf, s700, sizeof(__buf));
            bubble_c(__buf, sizeof(__buf));
        }
    }

    bench n800 {
        go: bubbleGo(s800)
        ts: bubbleTs(s800)
        c: {
            unsigned char __buf[sizeof(s800)];
            memcpy(__buf, s800, sizeof(__buf));
            bubble_c(__buf, sizeof(__buf));
        }
    }

    bench n900 {
        go: bubbleGo(s900)
        ts: bubbleTs(s900)
        c: {
            unsigned char __buf[sizeof(s900)];
            memcpy(__buf, s900, sizeof(__buf));
            bubble_c(__buf, sizeof(__buf));
        }
    }

    bench n1000 {
        go: bubbleGo(s1000)
        ts: bubbleTs(s1000)
        c: {
            unsigned char __buf[sizeof(s1000)];
            memcpy(__buf, s1000, sizeof(__buf));
            bubble_c(__buf, sizeof(__buf));
        }
    }

    after {
        charting.drawLineChart(
            title: "Bubble Sort - O(n²)",
            description: "Classic bubble sort - quadratic trend with regression + error overlays",
            output: "bubble-line-linear.svg",
            yScale: "linear",
            showStdDev: true,
            showErrorBars: true,
            showRegression: true,
            regressionModel: "auto",
        )
        charting.drawSpeedupChart(
            title: "Bubble Sort - O(n²)",
            description: "Relative performance vs baseline",
            output: "bubble-bar-speed.svg",
        )
        charting.drawTable(
            title: "Sort Performance Comparison",
            description: "Vertical grouped bars - Go vs TypeScript vs Rust",
            output: "bubble-table-curr.svg",
        )
    }
}
